{"version":3,"sources":["../static/js/5.74177cc3.chunk.js","components/DialogActions/SubmitOrCancelAction.js","components/DialogActions/OkAction.js","../node_modules/martinez-polygon-clipping/dist/martinez.umd.js","utils/geoprocessing/performActionOnAllFeaturePairs.js","../node_modules/@turf/difference/node_modules/@turf/helpers/index.js","components/LayerNameTextField.js","../node_modules/@turf/intersect/node_modules/@turf/helpers/index.js","../node_modules/@turf/difference/node_modules/@turf/meta/index.js","../node_modules/@turf/union/node_modules/@turf/helpers/index.js","components/Dialogs/GeoProcessingDialog.js","utils/geoprocessing/intersectFunction.js","../node_modules/@turf/intersect/index.js","../node_modules/@turf/intersect/node_modules/@turf/invariant/index.js","utils/geoprocessing/differenceFunction.js","../node_modules/@turf/difference/index.mjs","../node_modules/@turf/difference/node_modules/@turf/area/index.js","../node_modules/@turf/difference/node_modules/@turf/invariant/index.js","utils/geoprocessing/unionFunction.js","../node_modules/@turf/union/index.js","../node_modules/@turf/union/node_modules/@turf/invariant/index.js","utils/geoprocessing/combineFeatures.js","components/DoubleLayerPicker.js","components/LayersSelectSimple2.js","components/DialogContent/DialogFeedback.js"],"names":["webpackJsonp","5688","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1__material_ui_core__","__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","styles","theme","SubmitOrCancelAction","_Component","this","getPrototypeOf","apply","arguments","_props","submit","submitText","cancel","cancelText","submitDisabled","submitBtnTxt","cancelBtnTxt","disabled","a","createElement","variant","onClick","color","withTheme","5718","OkAction","ok","okText","okBtnTxt","5719","exports","global","factory","DEFAULT_COMPARE","b","loadRecursive","parent","keys","values","start","end","size","middle","Math","floor","data","node","left","right","sort","compare","pivot","j","tmp","computeFields","event","prev","operation","inOut","otherInOut","isSubject","isVertical","prevInResult","inResult","type","NORMAL","INTERSECTION","UNION","DIFFERENCE","XOR","SAME_TRANSITION","DIFFERENT_TRANSITION","NON_CONTRIBUTING","equals","p1","p2","signedArea","p0","compareEvents","e1","e2","point","specialCases","otherEvent","isBelow","divideSegment","se","p","queue","r","SweepEvent","l","console","warn","contourId","push","crossProduct","dotProduct","intersection","a1","a2","b1","b2","noEndpointTouch","toPoint","s","d","va","vb","e","kross","sqrKross","sqrLenA","t","sa","sb","smin","min","smax","max","possibleIntersection","se1","se2","inter","nintersections","events","leftCoincide","rightCoincide","compareSegments","le1","le2","isAbove","subdivide","eventQueue","subject","clipping","sbbox","cbbox","next","begin","sweepLine","SplayTree","sortedEvents","rightbound","pop","insert","minNode","prevEvent","prevprevEvent","prevprev","find","remove","orderEvents","len","resultEvents","sorted","pos","nextPos","processed","origIndex","newPos","connectEdges","result","contour","isExteriorRing","ringId","initial","resultInOut","TinyQueue","this$1","defaultCompare","_down","processPolygon","contourOrHole","depth","Q","bbox","s1","s2","undefined","x","y","fillQueue","polygonSet","ii","jj","tinyqueue","trivialOperation","EMPTY","compareBBoxes","concat","boolean","trivial","Infinity","union","diff","xor","intersection$1","noDuplicates","_compare","_root","_size","_noDuplicates","prototypeAccessors","rotateLeft","rotateRight","_splay","splay","gp","ggp","replace","u","v","maxNode","z","comp","cmp","contains","comparator","removeNode","erase","sMax","returnValue","successor","predecessor","forEach","callback","current","done","range","low","high","fn","ctx","at","index","load","presort","Error","isEmpty","get","createTree","edgeType","clone","copy","default_1","item","_up","top","peek","halfLength","best","default","operations","5720","performActionOnAllFeaturePairs","FeatureCollection1","FeatureCollection2","action","newGeojson","features","poly1","poly2","5721","feature","geom","properties","options","feat","id","geometry","coordinates","lineString","polygon","multiPoint","multiLineString","multiPolygon","points","featureCollection","map","coords","_i","coordinates_1","ring","polygons","lineStrings","fc","geometryCollection","geometries","round","num","precision","multiplier","pow","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","degrees","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","areaFactors","finalFactor","isNumber","isNaN","Array","isArray","test","isObject","input","validateBBox","validateId","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","earthRadius","centimeters","centimetres","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","acres","5722","__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__","__WEBPACK_IMPORTED_MODULE_2__material_ui_core___","__WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__","LayerNameTextField","_ref","_temp","_this","_ret","_len","args","_key","nameChange","name","setName","defaultName","setState","layerName","promt","layers","layerIndex","Nameerror","errorText","promtText","label","fullWidth","error","onChange","margin","helperText","InputLabelProps","shrink","5758","5759","coordEach","geojson","excludeWrapCoord","k","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","flattenEach","helpers","coordinate","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","5760","5845","__WEBPACK_IMPORTED_MODULE_2__material_ui_core__","__WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__","__WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__","__WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__","__WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__","__WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__","__WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__","__WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__","__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__","dialogPaper","minHeight","overflowX","spaced","marginBottom","container","display","flexWrap","width","GeoProcessingDialog","state","processingFunction","layerIds","outputName","errorMessage","setLayerIds","setProcessingFunction","func","calculate","_this$props","closeDialog","receiveNewJson","_this$state","l1","l2","data1","data2","newJson","handleClose","getContent","_this$props2","_this$state2","prompt1","prompt2","layerOptions","filter","layer","message","bind","style","spacing","unit","open","classes","content","actions","diaglogTitle","charAt","toUpperCase","slice","onClose","scroll","aria-labelledby","paper","5846","__WEBPACK_IMPORTED_MODULE_0__turf_intersect__","__WEBPACK_IMPORTED_MODULE_0__turf_intersect___default","__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__","intersectFunction","geojson1","geojson2","5847","intersect","geom1","invariant_1","getGeom","geom2","martinez","helpers_1","resultCoords","_a","subGeom","subIntersection","subIntGeom","__importStar","mod","__esModule","hasOwnProperty","5848","getCoord","getCoords","containsNumber","geojsonType","featureOf","collectionOf","getType","5849","__WEBPACK_IMPORTED_MODULE_0__turf_difference__","differenceFunction","5850","difference","polygon1","polygon2","__WEBPACK_IMPORTED_MODULE_3__turf_invariant__","removeEmptyPolygon","__WEBPACK_IMPORTED_MODULE_2__turf_helpers__","differenced","__WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__","__WEBPACK_IMPORTED_MODULE_1__turf_area___default","__WEBPACK_IMPORTED_MODULE_4__turf_meta__","__WEBPACK_IMPORTED_MODULE_1__turf_area__","5851","meta_1","calculateArea","total","polygonArea","abs","ringArea","p3","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","5852","5853","__WEBPACK_IMPORTED_MODULE_0__turf_union__","__WEBPACK_IMPORTED_MODULE_0__turf_union___default","__WEBPACK_IMPORTED_MODULE_2__combineFeatures__","unionFunction","5854","coords1","coords2","unioned","5855","5856","combineFeatures","5857","__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__","DoubleLayerPicker","changeLayer1","layerId","changeLayer2","className","changeLayer","5858","_defineProperty","obj","formControl","Select","LayersSelect","_React$Component","curValue","handleChange","setCurLayer","prevProps","displayName","htmlFor","placeholder","Component","5859","feedbackDiv","padding","borderRadius","DialogFeedback","bgcolor","backgroundColor"],"mappings":"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","file":"static/js/5.74177cc3.chunk.js","sourcesContent":["webpackJsonp([5],{\n\n/***/ 5688:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core__ = __webpack_require__(134);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var SubmitOrCancelAction=function(_Component){_inherits(SubmitOrCancelAction,_Component);function SubmitOrCancelAction(){_classCallCheck(this,SubmitOrCancelAction);return _possibleConstructorReturn(this,(SubmitOrCancelAction.__proto__||Object.getPrototypeOf(SubmitOrCancelAction)).apply(this,arguments));}_createClass(SubmitOrCancelAction,[{key:'render',value:function render(){var _props=this.props,submit=_props.submit,submitText=_props.submitText,cancel=_props.cancel,cancelText=_props.cancelText,submitDisabled=_props.submitDisabled;var submitBtnTxt=submitText?submitText:'Submit';var cancelBtnTxt=cancelText?cancelText:'Cancel';var disabled=submitDisabled?true:false;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"d\" /* DialogActions */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{variant:'contained',disabled:disabled,onClick:submit,color:'primary'},submitBtnTxt),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{onClick:cancel,color:'primary'},cancelBtnTxt));}}]);return SubmitOrCancelAction;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(SubmitOrCancelAction));\n\n/***/ }),\n\n/***/ 5718:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core__ = __webpack_require__(134);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var OkAction=function(_Component){_inherits(OkAction,_Component);function OkAction(){_classCallCheck(this,OkAction);return _possibleConstructorReturn(this,(OkAction.__proto__||Object.getPrototypeOf(OkAction)).apply(this,arguments));}_createClass(OkAction,[{key:'render',value:function render(){var _props=this.props,ok=_props.ok,okText=_props.okText;var okBtnTxt=okText?okText:'OK';return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"d\" /* DialogActions */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{onClick:ok,color:'primary'},okBtnTxt));}}]);return OkAction;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(OkAction));\n\n/***/ }),\n\n/***/ 5719:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.martinez = {})));\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n    if (newPos > length - 1) { return pos - 1; }\n    var p  = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point;\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n\n\n/***/ }),\n\n/***/ 5720:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar performActionOnAllFeaturePairs=function performActionOnAllFeaturePairs(FeatureCollection1,FeatureCollection2,action){var newGeojson={\"type\":\"FeatureCollection\",\"features\":[]};FeatureCollection1.features.forEach(function(poly1){FeatureCollection2.features.forEach(function(poly2){newGeojson.features.push(action(poly1,poly2));});});return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (performActionOnAllFeaturePairs);\n\n/***/ }),\n\n/***/ 5721:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 5722:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core___ = __webpack_require__(134);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__ = __webpack_require__(141);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var LayerNameTextField=function(_Component){_inherits(LayerNameTextField,_Component);function LayerNameTextField(){var _ref;var _temp,_this,_ret;_classCallCheck(this,LayerNameTextField);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=LayerNameTextField.__proto__||Object.getPrototypeOf(LayerNameTextField)).call.apply(_ref,[this].concat(args))),_this),_this.nameChange=function(name){return function(event){var setName=_this.props.setName;setName(event.target.value);};},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(LayerNameTextField,[{key:'componentDidMount',value:function componentDidMount(){var defaultName=this.props.defaultName;this.setState({layerName:defaultName});}},{key:'render',value:function render(){var _props=this.props,promt=_props.promt,layerName=_props.layerName,layers=_props.layers,layerIndex=_props.layerIndex;var Nameerror=false;var errorText='';if(layerName===''){errorText='layer name cannot be empty';Nameerror=true;}else if(Object(__WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__[\"a\" /* default */])(layerName,layers,layerIndex)){// Name exists already and is not the same as this layers names\nerrorText='That name is already in use';Nameerror=true;}var promtText=promt?promt:\"Layer Name\";return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('form',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core___[\"w\" /* TextField */],{id:'outlined-full-width',label:promtText,value:layerName,fullWidth:true,error:Nameerror,onChange:this.nameChange(''),margin:'normal',variant:'outlined',helperText:errorText,InputLabelProps:{shrink:true}}));}}]);return LayerNameTextField;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(LayerNameTextField));\n\n/***/ }),\n\n/***/ 5758:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 5759:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = __webpack_require__(5721);\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n\n\n/***/ }),\n\n/***/ 5760:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 5845:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(134);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__ = __webpack_require__(5688);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__ = __webpack_require__(5718);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__ = __webpack_require__(5846);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__ = __webpack_require__(5849);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__ = __webpack_require__(5853);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__ = __webpack_require__(5857);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__ = __webpack_require__(5722);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__ = __webpack_require__(5859);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{dialogPaper:{minHeight:'50vh',overflowX:'hidden'},spaced:{marginBottom:50},container:{display:'flex',flexWrap:'wrap',width:'100%'}};};var GeoProcessingDialog=function(_Component){_inherits(GeoProcessingDialog,_Component);function GeoProcessingDialog(){var _ref;var _temp,_this,_ret;_classCallCheck(this,GeoProcessingDialog);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=GeoProcessingDialog.__proto__||Object.getPrototypeOf(GeoProcessingDialog)).call.apply(_ref,[this].concat(args))),_this),_this.state={processingFunction:null,layerIds:['',''],//Ids of the selectedLayers\noutputName:'',errorMessage:''},_this.setLayerIds=function(layerIds){_this.setState({layerIds:layerIds});},_this.setProcessingFunction=function(type){var func=null;switch(type){case'intersect':func=__WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__[\"a\" /* default */];break;case'union':func=__WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__[\"a\" /* default */];break;case'difference':func=__WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__[\"a\" /* default */];break;default:break;}_this.setState({processingFunction:func});},_this.calculate=function(){var _this$props=_this.props,closeDialog=_this$props.closeDialog,layers=_this$props.layers,receiveNewJson=_this$props.receiveNewJson;var _this$state=_this.state,processingFunction=_this$state.processingFunction,layerIds=_this$state.layerIds,outputName=_this$state.outputName;var l1=layers.find(function(l){return l.id===layerIds[0];});var l2=layers.find(function(l){return l.id===layerIds[1];});var data1=void 0,data2=void 0;if(l1){data1=l1.data;}if(l2){data2=l2.data;}var newJson=processingFunction(data1,data2);if(newJson.type===\"FeatureCollection\"){receiveNewJson(newJson,outputName);closeDialog();}else{_this.setState({errorMessage:newJson});}},_this.handleClose=function(){var closeDialog=_this.props.closeDialog;closeDialog();},_this.setName=function(name){_this.setState({outputName:name});},_this.getContent=function(type){if(type==='intersect'||type==='difference'||type==='union'){var _this$props2=_this.props,layers=_this$props2.layers,theme=_this$props2.theme;var _this$state2=_this.state,outputName=_this$state2.outputName,errorMessage=_this$state2.errorMessage,layerIds=_this$state2.layerIds;var prompt1=type==='difference'?'Input Layer':'Layer 1';var prompt2=type==='difference'?'Difference Layer':'Layer 2';var l1=layers.find(function(l){return l.id===layerIds[0];});var l2=layers.find(function(l){return l.id===layerIds[1];});if(l1){prompt1+=' (Type: '+l1.data.features[0].geometry.type+')';}if(l2){prompt2+=' (Type: '+l2.data.features[0].geometry.type+')';}var layerOptions=layers;if(type==='intersect'||type==='difference'){layerOptions=layers.filter(function(layer){return layer.type==='Polygon'||layer.type==='MultiPolygon';});}return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,errorMessage.length>0?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__[\"a\" /* default */],{message:errorMessage,variant:'error'}):null,type==='intersect'||type==='difference'?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__[\"a\" /* default */],{message:type+' operation only accepts Polygons'}):null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__[\"a\" /* default */],{prompt1:prompt1,prompt2:prompt2,layers:layerOptions,setLayerIds:_this.setLayerIds.bind(_this)}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{style:{margin:theme.spacing.unit}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__[\"a\" /* default */],{layerName:outputName,setName:_this.setName.bind(_this),defaultName:outputName,layers:layerOptions,layerIndex:-1,promt:'Output layer name'})));};return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,type));},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(GeoProcessingDialog,[{key:'componentDidMount',value:function componentDidMount(){var type=this.props.type;this.setProcessingFunction(type);this.setState({outputName:type});}},{key:'render',value:function render(){var _props=this.props,open=_props.open,layers=_props.layers,type=_props.type,classes=_props.classes;var content=layers.length>0?this.getContent(type):__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,'Add some layers first'));var actions=layers.length>0?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__[\"a\" /* default */],{submitText:'Calculate',submit:this.calculate,cancel:this.handleClose}):__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__[\"a\" /* default */],{ok:this.handleClose});var diaglogTitle=type.charAt(0).toUpperCase()+type.slice(1);return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"c\" /* Dialog */],{fullWidth:true,open:open,onClose:this.handleClose,scroll:'paper','aria-labelledby':'scroll-dialog-title',classes:{paper:classes.dialogPaper}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"f\" /* DialogTitle */],{id:'scroll-dialog-title'},diaglogTitle),content,actions);}}]);return GeoProcessingDialog;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"default\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(GeoProcessingDialog));\n\n/***/ }),\n\n/***/ 5846:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_intersect__ = __webpack_require__(5847);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_intersect___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__turf_intersect__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5720);\nvar intersectFunction=function intersectFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!=='Polygon'&&geojson1.features[0].geometry.type!=='MultiPolygon'){return'The geometries must be of type Polygon or MultiPolygon.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_intersect___default.a);if(!newGeojson.features[0]){return'The geometries do not overlap';}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (intersectFunction);\n\n/***/ }),\n\n/***/ 5847:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5758);\r\nvar invariant_1 = __webpack_require__(5848);\r\nvar martinez = __importStar(__webpack_require__(5719));\r\n/**\r\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\r\n * finds their polygonal intersection. If they don't intersect, returns null.\r\n *\r\n * @name intersect\r\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\r\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\r\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\r\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *   [-122.801742, 45.48565],\r\n *   [-122.801742, 45.60491],\r\n *   [-122.584762, 45.60491],\r\n *   [-122.584762, 45.48565],\r\n *   [-122.801742, 45.48565]\r\n * ]]);\r\n *\r\n * var poly2 = turf.polygon([[\r\n *   [-122.520217, 45.535693],\r\n *   [-122.64038, 45.553967],\r\n *   [-122.720031, 45.526554],\r\n *   [-122.669906, 45.507309],\r\n *   [-122.723464, 45.446643],\r\n *   [-122.532577, 45.408574],\r\n *   [-122.487258, 45.477466],\r\n *   [-122.520217, 45.535693]\r\n * ]]);\r\n *\r\n * var intersection = turf.intersect(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, intersection];\r\n */\r\nfunction intersect(poly1, poly2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom1 = invariant_1.getGeom(poly1);\r\n    var geom2 = invariant_1.getGeom(poly2);\r\n    if (geom1.type === \"Polygon\" && geom2.type === \"Polygon\") {\r\n        var intersection = martinez.intersection(geom1.coordinates, geom2.coordinates);\r\n        if (intersection === null || intersection.length === 0) {\r\n            return null;\r\n        }\r\n        if (intersection.length === 1) {\r\n            var start = intersection[0][0][0];\r\n            var end = intersection[0][0][intersection[0][0].length - 1];\r\n            if (start[0] === end[0] && start[1] === end[1]) {\r\n                return helpers_1.polygon(intersection[0], options.properties);\r\n            }\r\n            return null;\r\n        }\r\n        return helpers_1.multiPolygon(intersection, options.properties);\r\n    }\r\n    else if (geom1.type === \"MultiPolygon\") {\r\n        var resultCoords = [];\r\n        // iterate through the polygon and run intersect with each part, adding to the resultCoords.\r\n        for (var _i = 0, _a = geom1.coordinates; _i < _a.length; _i++) {\r\n            var coords = _a[_i];\r\n            var subGeom = invariant_1.getGeom(helpers_1.polygon(coords));\r\n            var subIntersection = intersect(subGeom, geom2);\r\n            if (subIntersection) {\r\n                var subIntGeom = invariant_1.getGeom(subIntersection);\r\n                if (subIntGeom.type === \"Polygon\") {\r\n                    resultCoords.push(subIntGeom.coordinates);\r\n                }\r\n                else if (subIntGeom.type === \"MultiPolygon\") {\r\n                    resultCoords = resultCoords.concat(subIntGeom.coordinates);\r\n                }\r\n                else {\r\n                    throw new Error(\"intersection is invalid\");\r\n                }\r\n            }\r\n        }\r\n        // Make a polygon with the result\r\n        if (resultCoords.length === 0) {\r\n            return null;\r\n        }\r\n        if (resultCoords.length === 1) {\r\n            return helpers_1.polygon(resultCoords[0], options.properties);\r\n        }\r\n        else {\r\n            return helpers_1.multiPolygon(resultCoords, options.properties);\r\n        }\r\n    }\r\n    else if (geom2.type === \"MultiPolygon\") {\r\n        // geom1 is a polygon and geom2 a multiPolygon,\r\n        // put the multiPolygon first and fallback to the previous case.\r\n        return intersect(geom2, geom1);\r\n    }\r\n    else {\r\n        // handle invalid geometry types\r\n        throw new Error(\"poly1 and poly2 must be either polygons or multiPolygons\");\r\n    }\r\n}\r\nexports.default = intersect;\r\n\n\n/***/ }),\n\n/***/ 5848:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5758);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 5849:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_difference__ = __webpack_require__(5850);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5720);\nvar differenceFunction=function differenceFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!=='Polygon'&&geojson1.features[0].geometry.type!=='MultiPolygon'){return'The geometries must be of type Polygon or MultiPolygon.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_difference__[\"a\" /* default */]);if(!newGeojson.features[0]){return'There is no geometry left after performing the difference operation. Try swapping the order';}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (differenceFunction);\n\n/***/ }),\n\n/***/ 5850:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__ = __webpack_require__(5719);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_area__ = __webpack_require__(5851);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_area___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_area__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_helpers__ = __webpack_require__(5721);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_helpers___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant__ = __webpack_require__(5852);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__turf_meta__ = __webpack_require__(5759);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__turf_meta___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__turf_meta__);\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = Object(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__[\"getGeom\"])(polygon1);\r\n    var geom2 = Object(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__[\"getGeom\"])(polygon2);\r\n    var properties = polygon1.properties || {};\r\n\r\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\r\n    geom1 = removeEmptyPolygon(geom1);\r\n    geom2 = removeEmptyPolygon(geom2);\r\n    if (!geom1) return null;\r\n    if (!geom2) return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"feature\"])(geom1, properties);\r\n\r\n    var differenced = __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__[\"diff\"](geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    if (differenced.length === 1) return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"polygon\"])(differenced[0], properties);\r\n    return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"multiPolygon\"])(differenced, properties);\r\n}\r\n\r\n/**\r\n * Detect Empty Polygon\r\n *\r\n * @private\r\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\r\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\r\n */\r\nfunction removeEmptyPolygon(geom) {\r\n    switch (geom.type) {\r\n    case 'Polygon':\r\n        if (__WEBPACK_IMPORTED_MODULE_1__turf_area___default()(geom) > 1) return geom;\r\n        return null;\r\n    case 'MultiPolygon':\r\n        var coordinates = [];\r\n        Object(__WEBPACK_IMPORTED_MODULE_4__turf_meta__[\"flattenEach\"])(geom, function (feature) {\r\n            if (__WEBPACK_IMPORTED_MODULE_1__turf_area___default()(feature) > 1) coordinates.push(feature.geometry.coordinates);\r\n        });\r\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (difference);\r\n\n\n/***/ }),\n\n/***/ 5851:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = __webpack_require__(5759);\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n\n\n/***/ }),\n\n/***/ 5852:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5721);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 5853:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_union__ = __webpack_require__(5854);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_union___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__turf_union__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5720);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__combineFeatures__ = __webpack_require__(5856);\nvar unionFunction=function unionFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!==geojson2.features[0].geometry.type){return'The geometries must be of the same type.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=void 0;if(geojson1.features[0].geometry.type==='Polygon'){newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_union___default.a);}else{newGeojson=Object(__WEBPACK_IMPORTED_MODULE_2__combineFeatures__[\"a\" /* default */])(geojson1,geojson2);}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (unionFunction);\n\n/***/ }),\n\n/***/ 5854:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar martinez = __webpack_require__(5719);\r\nvar invariant_1 = __webpack_require__(5855);\r\nvar helpers_1 = __webpack_require__(5760);\r\n/**\r\n * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate Properties to output Feature\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(polygon1, polygon2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var coords1 = invariant_1.getGeom(polygon1).coordinates;\r\n    var coords2 = invariant_1.getGeom(polygon2).coordinates;\r\n    var unioned = martinez.union(coords1, coords2);\r\n    if (unioned.length === 0)\r\n        return null;\r\n    if (unioned.length === 1)\r\n        return helpers_1.polygon(unioned[0], options.properties);\r\n    else\r\n        return helpers_1.multiPolygon(unioned, options.properties);\r\n}\r\nexports.default = union;\r\n\n\n/***/ }),\n\n/***/ 5855:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5760);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 5856:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//combines the features of two feature collections into one\nvar combineFeatures=function combineFeatures(FeatureCollection1,FeatureCollection2){var newGeojson={\"type\":\"FeatureCollection\",\"features\":[]};newGeojson.features=FeatureCollection1.features.concat(FeatureCollection2.features);return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (combineFeatures);\n\n/***/ }),\n\n/***/ 5857:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__ = __webpack_require__(5858);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{spaced:{marginBottom:50},container:{display:'flex',flexWrap:'wrap',width:'100%'}};};var DoubleLayerPicker=function(_Component){_inherits(DoubleLayerPicker,_Component);function DoubleLayerPicker(){var _ref;var _temp,_this,_ret;_classCallCheck(this,DoubleLayerPicker);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=DoubleLayerPicker.__proto__||Object.getPrototypeOf(DoubleLayerPicker)).call.apply(_ref,[this].concat(args))),_this),_this.state={layerIds:['','']},_this.changeLayer1=function(layerId){var layerIds=_this.state.layerIds;var setLayerIds=_this.props.setLayerIds;layerIds[0]=layerId;setLayerIds(layerIds);_this.setState({layerIds:layerIds});},_this.changeLayer2=function(layerId){var layerIds=_this.state.layerIds;var setLayerIds=_this.props.setLayerIds;layerIds[1]=layerId;setLayerIds(layerIds);_this.setState({layerIds:layerIds});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(DoubleLayerPicker,[{key:'render',value:function render(){var _props=this.props,classes=_props.classes,prompt1=_props.prompt1,prompt2=_props.prompt2,layers=_props.layers;var layerIds=this.state.layerIds;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('form',{className:classes.container},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__[\"a\" /* default */],{className:classes.spaced,layers:layers,layerId:layerIds[0],changeLayer:this.changeLayer1.bind(this),promt:prompt1}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__[\"a\" /* default */],{className:classes.spaced,layers:layers,layerId:layerIds[1],changeLayer:this.changeLayer2.bind(this),promt:prompt2})));}}]);return DoubleLayerPicker;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(DoubleLayerPicker));/* <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(0).bind(this)} />\r\n            <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(2).bind(this)} />  */\n\n/***/ }),\n\n/***/ 5858:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(134);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}//This is prefered over the original. Uses ids over indices.\nvar styles=function styles(theme){return{formControl:{margin:theme.spacing.unit,width:'100%'},Select:{width:'100%'}};};var LayersSelect=function(_React$Component){_inherits(LayersSelect,_React$Component);function LayersSelect(){var _ref;var _temp,_this,_ret;_classCallCheck(this,LayersSelect);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=LayersSelect.__proto__||Object.getPrototypeOf(LayersSelect)).call.apply(_ref,[this].concat(args))),_this),_this.state={curValue:''},_this.handleChange=function(name){return function(event){var changeLayer=_this.props.changeLayer;changeLayer(event.target.value);_this.setState(_defineProperty({},name,event.target.value));};},_this.setCurLayer=function(){var layerId=_this.props.layerId;_this.setState({curValue:layerId});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(LayersSelect,[{key:'componentDidMount',value:function componentDidMount(){this.setCurLayer();}},{key:'componentDidUpdate',value:function componentDidUpdate(prevProps){if(prevProps.layerId!==this.props.layerId){this.setCurLayer();}}},{key:'render',value:function render(){var _props=this.props,layers=_props.layers,classes=_props.classes,promt=_props.promt;var options=layers.map(function(layer){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"q\" /* MenuItem */],{key:layer.id,value:layer.id},layer.displayName);});var promtText=promt?promt:'Choose a Layer';return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"i\" /* FormControl */],{fullWidth:true,className:classes.formControl},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"k\" /* InputLabel */],{htmlFor:'age-simple'},promtText),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"r\" /* Select */],{value:this.state.curValue,onChange:this.handleChange('curValue'),placeholder:'Choose a Layer to edit'},options));}}]);return LayersSelect;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(LayersSelect));\n\n/***/ }),\n\n/***/ 5859:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(134);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{feedbackDiv:{padding:theme.spacing.unit,borderRadius:5,margin:theme.spacing.unit}};};var DialogFeedback=function(_Component){_inherits(DialogFeedback,_Component);function DialogFeedback(){_classCallCheck(this,DialogFeedback);return _possibleConstructorReturn(this,(DialogFeedback.__proto__||Object.getPrototypeOf(DialogFeedback)).apply(this,arguments));}_createClass(DialogFeedback,[{key:'render',value:function render(){var _props=this.props,message=_props.message,classes=_props.classes,variant=_props.variant;var bgcolor='#2979ff';switch(variant){case'error':bgcolor='red';break;default:break;}return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{className:classes.feedbackDiv,style:{backgroundColor:bgcolor}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,' ',message));}}]);return DialogFeedback;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(DialogFeedback));\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/5.74177cc3.chunk.js","import React, {Component} from 'react';\r\nimport {\r\n    DialogActions,\r\n    Button} from '@material-ui/core'\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class SubmitOrCancelAction extends Component {\r\n    \r\n    render() {\r\n\r\n      const { submit, submitText , cancel, cancelText, submitDisabled } = this.props;\r\n\r\n      let submitBtnTxt = submitText ? submitText: 'Submit';\r\n      let cancelBtnTxt = cancelText ? cancelText: 'Cancel';\r\n      let disabled = submitDisabled ? true: false;\r\n  \r\n      return (\r\n        <DialogActions>\r\n            <Button variant='contained' disabled={disabled} onClick={submit}  color=\"primary\">\r\n              {submitBtnTxt}\r\n            </Button>\r\n            <Button onClick={cancel} color=\"primary\">\r\n              {cancelBtnTxt}\r\n            </Button>\r\n      </DialogActions>   \r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(SubmitOrCancelAction);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogActions/SubmitOrCancelAction.js","import React, {Component} from 'react';\r\nimport {\r\n    DialogActions,\r\n    Button} from '@material-ui/core'\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class OkAction extends Component {\r\n    \r\n    render() {\r\n\r\n      const { ok, okText } = this.props;\r\n\r\n      let okBtnTxt = okText ? okText: 'OK'\r\n  \r\n      return (\r\n        <DialogActions>\r\n            <Button onClick={ok}  color=\"primary\">\r\n              {okBtnTxt}\r\n            </Button>\r\n      </DialogActions>   \r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(OkAction);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogActions/OkAction.js","/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.martinez = {})));\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n    if (newPos > length - 1) { return pos - 1; }\n    var p  = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point;\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/martinez-polygon-clipping/dist/martinez.umd.js\n// module id = 5719\n// module chunks = 5","const performActionOnAllFeaturePairs = (FeatureCollection1, FeatureCollection2, action) => {\r\n\r\n    let newGeojson = {\r\n      \"type\": \"FeatureCollection\",\r\n      \"features\": []\r\n    }\r\n\r\n    FeatureCollection1.features.forEach(poly1 => {\r\n        FeatureCollection2.features.forEach(poly2 => {\r\n        newGeojson.features.push(action(poly1, poly2))\r\n      });\r\n    });\r\n\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default performActionOnAllFeaturePairs\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/performActionOnAllFeaturePairs.js","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/helpers/index.js\n// module id = 5721\n// module chunks = 5","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport {TextField} from '@material-ui/core/';\r\nimport checkIfLayerNameExists from '../utils/checkIfLayerNameExists';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class LayerNameTextField extends Component {\r\n\r\n    componentDidMount() {\r\n        const {defaultName} = this.props;\r\n        this.setState({layerName: defaultName})\r\n    }\r\n\r\n    nameChange = name => event => {\r\n        const {setName} = this.props;\r\n        setName(event.target.value);\r\n      }\r\n    \r\n    render() {\r\n\r\n      const { promt, layerName, layers, layerIndex} = this.props;\r\n\r\n      let Nameerror = false;\r\n      let errorText = '';\r\n  \r\n      if(layerName === '') {\r\n        errorText ='layer name cannot be empty';\r\n        Nameerror = true;\r\n      } else if ( checkIfLayerNameExists(layerName, layers, layerIndex)) {\r\n        // Name exists already and is not the same as this layers names\r\n        errorText ='That name is already in use';\r\n        Nameerror = true;\r\n      }\r\n      let promtText = promt? promt: \"Layer Name\";\r\n  \r\n      return (\r\n        <form>\r\n            <TextField\r\n            id=\"outlined-full-width\"\r\n            label={promtText}\r\n            value={layerName}\r\n            fullWidth={true}\r\n            error={Nameerror}\r\n            onChange={this.nameChange('')}      \r\n            margin=\"normal\"\r\n            variant=\"outlined\"\r\n            helperText={errorText}\r\n            InputLabelProps={{\r\n            shrink: true,\r\n            }}\r\n        />\r\n      </form>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(LayerNameTextField);\n\n\n// WEBPACK FOOTER //\n// ./src/components/LayerNameTextField.js","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/node_modules/@turf/helpers/index.js\n// module id = 5758\n// module chunks = 5","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/meta/index.js\n// module id = 5759\n// module chunks = 5","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/node_modules/@turf/helpers/index.js\n// module id = 5760\n// module chunks = 5","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport {Dialog,\r\n    Typography,\r\n    DialogContent,\r\n    DialogTitle,\r\n    } from '@material-ui/core';\r\nimport SubmitOrCancelAction from '../DialogActions/SubmitOrCancelAction';\r\nimport OkAction from '../DialogActions/OkAction'\r\nimport intersectFunction from '../../utils/geoprocessing/intersectFunction';\r\nimport differenceFunction from '../../utils/geoprocessing/differenceFunction';\r\nimport unionFunction from '../../utils/geoprocessing/unionFunction';\r\nimport DoubleLayerPicker from '../DoubleLayerPicker';\r\nimport LayerNameTextField from '../LayerNameTextField';\r\nimport DialogFeedback from '../DialogContent/DialogFeedback';\r\n\r\n\r\nconst styles = theme => ({\r\n    dialogPaper: {\r\n        minHeight: '50vh',\r\n        overflowX:'hidden'\r\n      },\r\n      spaced: {\r\n        marginBottom: 50,\r\n      },\r\n      container: {\r\n        display: 'flex',\r\n        flexWrap: 'wrap',\r\n        width:'100%'\r\n      },\r\n  });\r\n\r\n  class GeoProcessingDialog extends Component {\r\n    state = {\r\n        processingFunction: null,\r\n        layerIds: ['', ''], //Ids of the selectedLayers\r\n        outputName:'',\r\n        errorMessage:''\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {type} = this.props;\r\n        this.setProcessingFunction(type);\r\n        this.setState({outputName: type});\r\n    }\r\n\r\n    setLayerIds = (layerIds) => {\r\n      this.setState({layerIds: layerIds})\r\n    }\r\n\r\n    setProcessingFunction = (type) => {\r\n        let func = null;\r\n  \r\n        switch (type) {\r\n          case 'intersect':\r\n            func = intersectFunction;\r\n            break;\r\n          case 'union':\r\n            func = unionFunction;\r\n            break;\r\n          case 'difference':\r\n            func = differenceFunction;\r\n            break;\r\n        \r\n          default:\r\n            break;\r\n        }\r\n        this.setState({processingFunction: func});\r\n      }\r\n\r\n    calculate = () => {\r\n    const {closeDialog, layers, receiveNewJson} = this.props;\r\n    const {processingFunction, layerIds, outputName} = this.state;\r\n\r\n    let l1 = layers.find( l => l.id === layerIds[0] );\r\n    let l2 = layers.find( l => l.id === layerIds[1] );\r\n    let data1, data2;\r\n\r\n      if (l1) {\r\n        data1 = l1.data;\r\n      } if (l2) {\r\n        data2 = l2.data;\r\n      } \r\n\r\n       let newJson = processingFunction(data1, data2);\r\n\r\n       if(newJson.type === \"FeatureCollection\") {\r\n        receiveNewJson(newJson, outputName)\r\n        closeDialog();\r\n       } else {\r\n         this.setState({errorMessage: newJson});\r\n       }\r\n       \r\n    };\r\n\r\n    handleClose = () => {\r\n        const {closeDialog} = this.props;\r\n        closeDialog();\r\n    };\r\n\r\n    setName  = (name) => {\r\n      this.setState({outputName: name});\r\n    }\r\n\r\n    getContent = type => {\r\n      \r\n      if(type === 'intersect' || type === 'difference' || type === 'union'){\r\n        const {layers, theme} = this.props;\r\n        const {outputName, errorMessage, layerIds} = this.state;\r\n        let prompt1 = type === 'difference' ? 'Input Layer' : 'Layer 1'\r\n        let prompt2 = type === 'difference' ? 'Difference Layer' : 'Layer 2'\r\n\r\n        let l1 = layers.find( l => l.id === layerIds[0] )\r\n        let l2 = layers.find( l => l.id === layerIds[1] )\r\n\r\n        if(l1) {\r\n          prompt1 += ' (Type: ' + l1.data.features[0].geometry.type  + ')'\r\n        }\r\n        if(l2) {\r\n          prompt2 += ' (Type: ' + l2.data.features[0].geometry.type  + ')'\r\n        }\r\n\r\n        let layerOptions = layers;\r\n\r\n        if (type === 'intersect' || type === 'difference' ) {\r\n          layerOptions = layers.filter(layer => layer.type === 'Polygon' || layer.type === 'MultiPolygon' );\r\n        }\r\n\r\n        return (\r\n            <DialogContent>\r\n              {errorMessage.length > 0 ?\r\n                <DialogFeedback message={errorMessage} variant={'error'} />\r\n                : null\r\n              }\r\n              {type === 'intersect' || type === 'difference'  ?\r\n                <DialogFeedback message={type + ' operation only accepts Polygons'}/>\r\n                :\r\n                null\r\n              }\r\n              \r\n              <DoubleLayerPicker prompt1={prompt1}\r\n                  prompt2={prompt2}\r\n                  layers={layerOptions}\r\n                  setLayerIds={this.setLayerIds.bind(this)}/>\r\n                <div style={{margin: theme.spacing.unit}}>\r\n                <LayerNameTextField\r\n                  layerName={outputName}\r\n                  setName={this.setName.bind(this)}\r\n                  defaultName={outputName}\r\n                  layers={layerOptions}\r\n                  layerIndex={-1}\r\n                  promt={'Output layer name'} />\r\n                \r\n                  </div>         \r\n            </DialogContent> );\r\n        };\r\n\r\n        return (\r\n            <DialogContent>\r\n                <Typography>{type}</Typography>            \r\n            </DialogContent> );\r\n    }\r\n\r\n\r\n    \r\n    render() {\r\n\r\n      const {open, layers, type, classes} = this.props;\r\n     \r\n      let content = layers.length > 0 ?\r\n      this.getContent(type)\r\n      : \r\n      <DialogContent>\r\n        <Typography>Add some layers first</Typography>         \r\n      </DialogContent>\r\n\r\n        let actions = layers.length > 0 ?\r\n        <SubmitOrCancelAction submitText='Calculate' submit={this.calculate} cancel={this.handleClose}/>\r\n        : \r\n        <OkAction ok={this.handleClose}/>\r\n\r\n        let diaglogTitle = type.charAt(0).toUpperCase() + type.slice(1);\r\n  \r\n      return (\r\n        <Dialog\r\n        fullWidth={true}\r\n        open={open}\r\n        onClose={this.handleClose}\r\n        scroll={'paper'}\r\n        aria-labelledby=\"scroll-dialog-title\"\r\n        classes={{ paper: classes.dialogPaper }}\r\n        \r\n      >\r\n          <DialogTitle id=\"scroll-dialog-title\">{diaglogTitle}</DialogTitle>\r\n            {content}\r\n            {actions}\r\n      </Dialog>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(GeoProcessingDialog);\n\n\n// WEBPACK FOOTER //\n// ./src/components/Dialogs/GeoProcessingDialog.js","import  intersect from '@turf/intersect';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\n\r\nconst intersectFunction = (geojson1, geojson2) => {\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== 'Polygon' && geojson1.features[0].geometry.type !== 'MultiPolygon'  ) {\r\n    return 'The geometries must be of type Polygon or MultiPolygon.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n  \r\n  let newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, intersect)\r\n    if (!newGeojson.features[0]) {\r\n      return 'The geometries do not overlap'\r\n    }\r\n    return newGeojson;\r\n  }\r\n\r\n  export default intersectFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/intersectFunction.js","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\nvar invariant_1 = require(\"@turf/invariant\");\r\nvar martinez = __importStar(require(\"martinez-polygon-clipping\"));\r\n/**\r\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\r\n * finds their polygonal intersection. If they don't intersect, returns null.\r\n *\r\n * @name intersect\r\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\r\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\r\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\r\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *   [-122.801742, 45.48565],\r\n *   [-122.801742, 45.60491],\r\n *   [-122.584762, 45.60491],\r\n *   [-122.584762, 45.48565],\r\n *   [-122.801742, 45.48565]\r\n * ]]);\r\n *\r\n * var poly2 = turf.polygon([[\r\n *   [-122.520217, 45.535693],\r\n *   [-122.64038, 45.553967],\r\n *   [-122.720031, 45.526554],\r\n *   [-122.669906, 45.507309],\r\n *   [-122.723464, 45.446643],\r\n *   [-122.532577, 45.408574],\r\n *   [-122.487258, 45.477466],\r\n *   [-122.520217, 45.535693]\r\n * ]]);\r\n *\r\n * var intersection = turf.intersect(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, intersection];\r\n */\r\nfunction intersect(poly1, poly2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom1 = invariant_1.getGeom(poly1);\r\n    var geom2 = invariant_1.getGeom(poly2);\r\n    if (geom1.type === \"Polygon\" && geom2.type === \"Polygon\") {\r\n        var intersection = martinez.intersection(geom1.coordinates, geom2.coordinates);\r\n        if (intersection === null || intersection.length === 0) {\r\n            return null;\r\n        }\r\n        if (intersection.length === 1) {\r\n            var start = intersection[0][0][0];\r\n            var end = intersection[0][0][intersection[0][0].length - 1];\r\n            if (start[0] === end[0] && start[1] === end[1]) {\r\n                return helpers_1.polygon(intersection[0], options.properties);\r\n            }\r\n            return null;\r\n        }\r\n        return helpers_1.multiPolygon(intersection, options.properties);\r\n    }\r\n    else if (geom1.type === \"MultiPolygon\") {\r\n        var resultCoords = [];\r\n        // iterate through the polygon and run intersect with each part, adding to the resultCoords.\r\n        for (var _i = 0, _a = geom1.coordinates; _i < _a.length; _i++) {\r\n            var coords = _a[_i];\r\n            var subGeom = invariant_1.getGeom(helpers_1.polygon(coords));\r\n            var subIntersection = intersect(subGeom, geom2);\r\n            if (subIntersection) {\r\n                var subIntGeom = invariant_1.getGeom(subIntersection);\r\n                if (subIntGeom.type === \"Polygon\") {\r\n                    resultCoords.push(subIntGeom.coordinates);\r\n                }\r\n                else if (subIntGeom.type === \"MultiPolygon\") {\r\n                    resultCoords = resultCoords.concat(subIntGeom.coordinates);\r\n                }\r\n                else {\r\n                    throw new Error(\"intersection is invalid\");\r\n                }\r\n            }\r\n        }\r\n        // Make a polygon with the result\r\n        if (resultCoords.length === 0) {\r\n            return null;\r\n        }\r\n        if (resultCoords.length === 1) {\r\n            return helpers_1.polygon(resultCoords[0], options.properties);\r\n        }\r\n        else {\r\n            return helpers_1.multiPolygon(resultCoords, options.properties);\r\n        }\r\n    }\r\n    else if (geom2.type === \"MultiPolygon\") {\r\n        // geom1 is a polygon and geom2 a multiPolygon,\r\n        // put the multiPolygon first and fallback to the previous case.\r\n        return intersect(geom2, geom1);\r\n    }\r\n    else {\r\n        // handle invalid geometry types\r\n        throw new Error(\"poly1 and poly2 must be either polygons or multiPolygons\");\r\n    }\r\n}\r\nexports.default = intersect;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/index.js\n// module id = 5847\n// module chunks = 5","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/node_modules/@turf/invariant/index.js\n// module id = 5848\n// module chunks = 5","import  difference from '@turf/difference';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\n\r\nconst differenceFunction = (geojson1, geojson2) => {\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== 'Polygon' && geojson1.features[0].geometry.type !== 'MultiPolygon'  ) {\r\n    return 'The geometries must be of type Polygon or MultiPolygon.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n    let newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, difference)\r\n    if (!newGeojson.features[0]) {\r\n      return 'There is no geometry left after performing the difference operation. Try swapping the order'\r\n    }\r\n    return(newGeojson);\r\n    \r\n  }\r\n\r\n  export default differenceFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/differenceFunction.js","import * as martinez from 'martinez-polygon-clipping';\r\nimport area from '@turf/area';\r\nimport { feature, multiPolygon, polygon } from '@turf/helpers';\r\nimport { getGeom } from '@turf/invariant';\r\nimport { flattenEach } from '@turf/meta';\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = getGeom(polygon1);\r\n    var geom2 = getGeom(polygon2);\r\n    var properties = polygon1.properties || {};\r\n\r\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\r\n    geom1 = removeEmptyPolygon(geom1);\r\n    geom2 = removeEmptyPolygon(geom2);\r\n    if (!geom1) return null;\r\n    if (!geom2) return feature(geom1, properties);\r\n\r\n    var differenced = martinez.diff(geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    if (differenced.length === 1) return polygon(differenced[0], properties);\r\n    return multiPolygon(differenced, properties);\r\n}\r\n\r\n/**\r\n * Detect Empty Polygon\r\n *\r\n * @private\r\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\r\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\r\n */\r\nfunction removeEmptyPolygon(geom) {\r\n    switch (geom.type) {\r\n    case 'Polygon':\r\n        if (area(geom) > 1) return geom;\r\n        return null;\r\n    case 'MultiPolygon':\r\n        var coordinates = [];\r\n        flattenEach(geom, function (feature) {\r\n            if (area(feature) > 1) coordinates.push(feature.geometry.coordinates);\r\n        });\r\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\r\n    }\r\n}\r\n\r\nexport default difference;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/index.mjs\n// module id = 5850\n// module chunks = 5","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/area/index.js\n// module id = 5851\n// module chunks = 5","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/invariant/index.js\n// module id = 5852\n// module chunks = 5","import  union from '@turf/union';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\nimport combineFeatures from './combineFeatures';\r\n\r\nconst unionFunction = (geojson1, geojson2) => {\r\n\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== geojson2.features[0].geometry.type ) {\r\n    return 'The geometries must be of the same type.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n\r\n  let newGeojson;\r\n\r\n  if(geojson1.features[0].geometry.type === 'Polygon') {\r\n    newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, union);\r\n  } else {\r\n    newGeojson =  combineFeatures(geojson1, geojson2)\r\n  }\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default unionFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/unionFunction.js","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar martinez = require(\"martinez-polygon-clipping\");\r\nvar invariant_1 = require(\"@turf/invariant\");\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate Properties to output Feature\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(polygon1, polygon2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var coords1 = invariant_1.getGeom(polygon1).coordinates;\r\n    var coords2 = invariant_1.getGeom(polygon2).coordinates;\r\n    var unioned = martinez.union(coords1, coords2);\r\n    if (unioned.length === 0)\r\n        return null;\r\n    if (unioned.length === 1)\r\n        return helpers_1.polygon(unioned[0], options.properties);\r\n    else\r\n        return helpers_1.multiPolygon(unioned, options.properties);\r\n}\r\nexports.default = union;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/index.js\n// module id = 5854\n// module chunks = 5","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/node_modules/@turf/invariant/index.js\n// module id = 5855\n// module chunks = 5","//combines the features of two feature collections into one\r\nconst combineFeatures = (FeatureCollection1, FeatureCollection2) => {\r\n\r\n    let newGeojson = {\r\n      \"type\": \"FeatureCollection\",\r\n      \"features\": []\r\n    }\r\n\r\n    newGeojson.features = FeatureCollection1.features.concat(FeatureCollection2.features);\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default combineFeatures\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/combineFeatures.js","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport LayersSelect from './LayersSelectSimple2';\r\n\r\nconst styles = theme => ({\r\n    spaced: {\r\n      marginBottom: 50,\r\n    },\r\n    container: {\r\n      display: 'flex',\r\n      flexWrap: 'wrap',\r\n      width:'100%'\r\n    },\r\n  });\r\n\r\n  class DoubleLayerPicker extends Component {\r\n    state = {\r\n      layerIds: ['', '']\r\n    };\r\n\r\n    changeLayer1 = (layerId) => {\r\n      let {layerIds} = this.state;\r\n      let {setLayerIds} = this.props;\r\n\r\n      layerIds[0] = layerId;\r\n      setLayerIds(layerIds);\r\n \r\n      this.setState({\r\n        layerIds: layerIds,\r\n      });\r\n    }\r\n\r\n    changeLayer2 = (layerId) => {\r\n      let {layerIds} = this.state;\r\n      let {setLayerIds} = this.props;\r\n\r\n      layerIds[1] = layerId;\r\n      setLayerIds(layerIds);\r\n \r\n      this.setState({\r\n        layerIds: layerIds,\r\n      });\r\n    }\r\n    \r\n    render() {\r\n\r\n      const { classes,  prompt1, prompt2, layers } = this.props;\r\n      const {layerIds} = this.state;\r\n  \r\n      return (\r\n        <div>\r\n        <form className={classes.container}>\r\n        <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerId={layerIds[0]}\r\n            changeLayer={this.changeLayer1.bind(this)}\r\n            promt={prompt1} />\r\n          <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerId={layerIds[1]}\r\n            changeLayer={this.changeLayer2.bind(this)}\r\n            promt={prompt2} />\r\n        </form>\r\n        </div>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(DoubleLayerPicker);\r\n         /* <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(0).bind(this)} />\r\n            <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(2).bind(this)} />  */\n\n\n// WEBPACK FOOTER //\n// ./src/components/DoubleLayerPicker.js","\r\nimport React from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport { FormControl, InputLabel, MenuItem, Select}  from '@material-ui/core'\r\n\r\n//This is prefered over the original. Uses ids over indices.\r\n\r\nconst styles = theme => ({\r\n  formControl: {\r\n    margin: theme.spacing.unit,\r\n    width: '100%',\r\n  },\r\n  Select:{\r\n    width: '100%',\r\n  }\r\n});\r\n\r\n\r\n\r\nclass LayersSelect extends React.Component {\r\n  state = {\r\n    curValue: '',\r\n  };\r\n\r\n  handleChange = name => event => {\r\n    const {changeLayer} = this.props\r\n\r\n    changeLayer(event.target.value)\r\n    this.setState({ [name]: event.target.value });\r\n  };\r\n\r\n  componentDidMount() {\r\n    this.setCurLayer();\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.layerId !== this.props.layerId) {\r\n      this.setCurLayer();\r\n    }\r\n  }\r\n\r\n  setCurLayer = () => {\r\n    const {layerId} = this.props;\r\n\r\n    this.setState({curValue: layerId});\r\n  }\r\n\r\n  render() {\r\n    const { layers, classes, promt } = this.props;\r\n    let options = layers.map((layer) => {\r\n\r\n      return <MenuItem key={layer.id} value={layer.id}>{layer.displayName}</MenuItem >\r\n\r\n    }); \r\n\r\n    let promtText = promt ? promt : 'Choose a Layer';\r\n\r\n    return (\r\n\r\n    <FormControl fullWidth={true} className={classes.formControl}>\r\n      <InputLabel htmlFor=\"age-simple\">{promtText}</InputLabel>\r\n      <Select\r\n        value={this.state.curValue}\r\n        onChange={this.handleChange('curValue')}\r\n        placeholder=\"Choose a Layer to edit\"\r\n      >\r\n        {options}\r\n      </Select>\r\n    </FormControl>\r\n    );\r\n  }\r\n}\r\n\r\nexport default withStyles(styles, { withTheme: true })(LayersSelect);\n\n\n// WEBPACK FOOTER //\n// ./src/components/LayersSelectSimple2.js","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport { Typography} from '@material-ui/core';\r\n\r\nconst styles = theme => ({\r\n    feedbackDiv: {\r\n       padding: theme.spacing.unit,\r\n       borderRadius: 5,\r\n       margin: theme.spacing.unit\r\n\r\n    }\r\n  });\r\n\r\n  class DialogFeedback extends Component {\r\n    \r\n    render() {\r\n\r\n      const { message, classes, variant } = this.props;\r\n\r\n      let bgcolor = '#2979ff'\r\n\r\n      switch (variant) {\r\n          case 'error':\r\n            bgcolor = 'red';\r\n            break;              \r\n      \r\n          default:\r\n              break;\r\n      }\r\n  \r\n      return (\r\n        <div className={classes.feedbackDiv} style={{backgroundColor: bgcolor}}>\r\n            <Typography> {message}</Typography>\r\n        </div>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(DialogFeedback);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogContent/DialogFeedback.js"],"sourceRoot":""}
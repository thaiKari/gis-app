{"version":3,"sources":["../static/js/6.d8a4c15d.chunk.js","components/DialogActions/SubmitOrCancelAction.js","components/DialogActions/OkAction.js","components/LayerNameTextField.js","../node_modules/martinez-polygon-clipping/dist/martinez.umd.js","utils/geoprocessing/performActionOnAllFeaturePairs.js","../node_modules/@turf/difference/node_modules/@turf/helpers/index.js","../node_modules/@turf/intersect/node_modules/@turf/helpers/index.js","../node_modules/@turf/difference/node_modules/@turf/meta/index.js","../node_modules/@turf/union/node_modules/@turf/helpers/index.js","components/Dialogs/GeoProcessingDialog.js","utils/geoprocessing/intersectFunction.js","../node_modules/@turf/intersect/index.js","../node_modules/@turf/intersect/node_modules/@turf/invariant/index.js","utils/geoprocessing/differenceFunction.js","../node_modules/@turf/difference/index.mjs","../node_modules/@turf/difference/node_modules/@turf/area/index.js","../node_modules/@turf/difference/node_modules/@turf/invariant/index.js","utils/geoprocessing/unionFunction.js","../node_modules/@turf/union/index.js","../node_modules/@turf/union/node_modules/@turf/invariant/index.js","utils/geoprocessing/combineFeatures.js","components/DoubleLayerPicker.js","components/LayersSelectSimple2.js","components/DialogContent/DialogFeedback.js"],"names":["webpackJsonp","5803","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1__material_ui_core__","__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","styles","theme","SubmitOrCancelAction","_Component","this","getPrototypeOf","apply","arguments","_props","submit","submitText","cancel","cancelText","submitDisabled","submitBtnTxt","cancelBtnTxt","disabled","a","createElement","variant","onClick","color","withTheme","5824","OkAction","ok","okText","okBtnTxt","5840","__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__","__WEBPACK_IMPORTED_MODULE_2__material_ui_core___","__WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__","LayerNameTextField","_ref","_temp","_this","_ret","_len","args","Array","_key","concat","nameChange","name","event","setName","defaultName","setState","layerName","promt","layers","layerIndex","Nameerror","errorText","promtText","id","label","fullWidth","error","onChange","margin","helperText","InputLabelProps","shrink","5851","exports","global","factory","DEFAULT_COMPARE","b","loadRecursive","parent","keys","values","start","end","size","middle","Math","floor","data","node","left","right","sort","compare","pivot","j","tmp","computeFields","prev","operation","inOut","otherInOut","isSubject","isVertical","prevInResult","inResult","type","NORMAL","INTERSECTION","UNION","DIFFERENCE","XOR","SAME_TRANSITION","DIFFERENT_TRANSITION","NON_CONTRIBUTING","equals","p1","p2","signedArea","p0","compareEvents","e1","e2","point","specialCases","otherEvent","isBelow","divideSegment","se","p","queue","r","SweepEvent","l","console","warn","contourId","push","crossProduct","dotProduct","intersection","a1","a2","b1","b2","noEndpointTouch","toPoint","s","d","va","vb","e","kross","sqrKross","sqrLenA","t","sa","sb","smin","min","smax","max","possibleIntersection","se1","se2","inter","nintersections","events","leftCoincide","rightCoincide","compareSegments","le1","le2","isAbove","subdivide","eventQueue","subject","clipping","sbbox","cbbox","next","begin","sweepLine","SplayTree","sortedEvents","rightbound","pop","insert","minNode","prevEvent","prevprevEvent","prevprev","find","remove","orderEvents","len","resultEvents","sorted","pos","nextPos","processed","origIndex","newPos","connectEdges","result","contour","isExteriorRing","ringId","initial","resultInOut","TinyQueue","this$1","defaultCompare","_down","processPolygon","contourOrHole","depth","Q","bbox","s1","s2","undefined","x","y","fillQueue","polygonSet","ii","jj","tinyqueue","trivialOperation","EMPTY","compareBBoxes","boolean","trivial","Infinity","union","diff","xor","intersection$1","noDuplicates","_compare","_root","_size","_noDuplicates","prototypeAccessors","rotateLeft","rotateRight","_splay","splay","gp","ggp","replace","u","v","maxNode","z","comp","cmp","contains","comparator","removeNode","erase","sMax","returnValue","successor","predecessor","forEach","callback","current","done","range","low","high","fn","ctx","at","index","load","presort","Error","isEmpty","get","createTree","edgeType","clone","copy","default_1","item","_up","top","peek","halfLength","best","default","operations","5852","performActionOnAllFeaturePairs","FeatureCollection1","FeatureCollection2","action","newGeojson","features","poly1","poly2","5853","feature","geom","properties","options","feat","geometry","coordinates","lineString","polygon","multiPoint","multiLineString","multiPolygon","points","featureCollection","map","coords","_i","coordinates_1","ring","polygons","lineStrings","fc","geometryCollection","geometries","round","num","precision","multiplier","pow","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","PI","degreesToRadians","degrees","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","areaFactors","finalFactor","isNumber","isNaN","isArray","test","isObject","input","validateBBox","validateId","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","earthRadius","centimeters","centimetres","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","acres","5906","5907","coordEach","geojson","excludeWrapCoord","k","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","coord","geomEach","g","featureProperties","featureBBox","featureId","geomReduce","currentGeometry","flattenEach","helpers","coordinate","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","findPoint","5908","6141","__WEBPACK_IMPORTED_MODULE_2__material_ui_core__","__WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__","__WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__","__WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__","__WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__","__WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__","__WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__","__WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__","__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__","dialogPaper","minHeight","overflowX","spaced","marginBottom","container","display","flexWrap","width","GeoProcessingDialog","state","processingFunction","layerIds","outputName","errorMessage","setLayerIds","setProcessingFunction","func","calculate","_this$props","closeDialog","receiveNewJson","_this$state","l1","l2","data1","data2","newJson","handleClose","getContent","_this$props2","_this$state2","prompt1","prompt2","layerOptions","filter","layer","message","bind","style","spacing","unit","open","classes","content","actions","diaglogTitle","charAt","toUpperCase","slice","onClose","scroll","aria-labelledby","paper","6142","__WEBPACK_IMPORTED_MODULE_0__turf_intersect__","__WEBPACK_IMPORTED_MODULE_0__turf_intersect___default","__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__","intersectFunction","geojson1","geojson2","6143","intersect","geom1","invariant_1","getGeom","geom2","martinez","helpers_1","resultCoords","_a","subGeom","subIntersection","subIntGeom","__importStar","mod","__esModule","hasOwnProperty","6144","getCoord","getCoords","containsNumber","geojsonType","featureOf","collectionOf","getType","6145","__WEBPACK_IMPORTED_MODULE_0__turf_difference__","differenceFunction","6146","difference","polygon1","polygon2","__WEBPACK_IMPORTED_MODULE_3__turf_invariant__","removeEmptyPolygon","__WEBPACK_IMPORTED_MODULE_2__turf_helpers__","differenced","__WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__","__WEBPACK_IMPORTED_MODULE_1__turf_area___default","__WEBPACK_IMPORTED_MODULE_4__turf_meta__","__WEBPACK_IMPORTED_MODULE_1__turf_area__","6147","meta_1","calculateArea","total","polygonArea","abs","ringArea","p3","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","RADIUS","6148","6149","__WEBPACK_IMPORTED_MODULE_0__turf_union__","__WEBPACK_IMPORTED_MODULE_0__turf_union___default","__WEBPACK_IMPORTED_MODULE_2__combineFeatures__","unionFunction","6150","coords1","coords2","unioned","6151","6152","combineFeatures","6153","__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__","DoubleLayerPicker","changeLayer1","layerId","changeLayer2","className","changeLayer","6154","_defineProperty","obj","formControl","Select","LayersSelect","_React$Component","curValue","handleChange","setCurLayer","prevProps","displayName","htmlFor","placeholder","Component","6155","feedbackDiv","padding","borderRadius","DialogFeedback","bgcolor","backgroundColor"],"mappings":"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","file":"static/js/6.d8a4c15d.chunk.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 5803:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var SubmitOrCancelAction=function(_Component){_inherits(SubmitOrCancelAction,_Component);function SubmitOrCancelAction(){_classCallCheck(this,SubmitOrCancelAction);return _possibleConstructorReturn(this,(SubmitOrCancelAction.__proto__||Object.getPrototypeOf(SubmitOrCancelAction)).apply(this,arguments));}_createClass(SubmitOrCancelAction,[{key:'render',value:function render(){var _props=this.props,submit=_props.submit,submitText=_props.submitText,cancel=_props.cancel,cancelText=_props.cancelText,submitDisabled=_props.submitDisabled;var submitBtnTxt=submitText?submitText:'Submit';var cancelBtnTxt=cancelText?cancelText:'Cancel';var disabled=submitDisabled?true:false;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"d\" /* DialogActions */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{variant:'contained',disabled:disabled,onClick:submit,color:'primary'},submitBtnTxt),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{onClick:cancel,color:'primary'},cancelBtnTxt));}}]);return SubmitOrCancelAction;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(SubmitOrCancelAction));\n\n/***/ }),\n\n/***/ 5824:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var OkAction=function(_Component){_inherits(OkAction,_Component);function OkAction(){_classCallCheck(this,OkAction);return _possibleConstructorReturn(this,(OkAction.__proto__||Object.getPrototypeOf(OkAction)).apply(this,arguments));}_createClass(OkAction,[{key:'render',value:function render(){var _props=this.props,ok=_props.ok,okText=_props.okText;var okBtnTxt=okText?okText:'OK';return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"d\" /* DialogActions */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__material_ui_core__[\"b\" /* Button */],{onClick:ok,color:'primary'},okBtnTxt));}}]);return OkAction;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_2__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(OkAction));\n\n/***/ }),\n\n/***/ 5840:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core___ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__ = __webpack_require__(193);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{};};var LayerNameTextField=function(_Component){_inherits(LayerNameTextField,_Component);function LayerNameTextField(){var _ref;var _temp,_this,_ret;_classCallCheck(this,LayerNameTextField);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=LayerNameTextField.__proto__||Object.getPrototypeOf(LayerNameTextField)).call.apply(_ref,[this].concat(args))),_this),_this.nameChange=function(name){return function(event){var setName=_this.props.setName;setName(event.target.value);};},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(LayerNameTextField,[{key:'componentDidMount',value:function componentDidMount(){var defaultName=this.props.defaultName;this.setState({layerName:defaultName});}},{key:'render',value:function render(){var _props=this.props,promt=_props.promt,layerName=_props.layerName,layers=_props.layers,layerIndex=_props.layerIndex;var Nameerror=false;var errorText='';if(layerName===''){errorText='layer name cannot be empty';Nameerror=true;}else if(Object(__WEBPACK_IMPORTED_MODULE_3__utils_checkIfLayerNameExists__[\"a\" /* default */])(layerName,layers,layerIndex)){// Name exists already and is not the same as this layers names\nerrorText='That name is already in use';Nameerror=true;}var promtText=promt?promt:\"Layer Name\";return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('form',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core___[\"w\" /* TextField */],{id:'outlined-full-width',label:promtText,value:layerName,fullWidth:true,error:Nameerror,onChange:this.nameChange(''),margin:'normal',variant:'outlined',helperText:errorText,InputLabelProps:{shrink:true}}));}}]);return LayerNameTextField;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(LayerNameTextField));\n\n/***/ }),\n\n/***/ 5851:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.martinez = {})));\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n    if (newPos > length - 1) { return pos - 1; }\n    var p  = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point;\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n\n\n/***/ }),\n\n/***/ 5852:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar performActionOnAllFeaturePairs=function performActionOnAllFeaturePairs(FeatureCollection1,FeatureCollection2,action){var newGeojson={\"type\":\"FeatureCollection\",\"features\":[]};FeatureCollection1.features.forEach(function(poly1){FeatureCollection2.features.forEach(function(poly2){newGeojson.features.push(action(poly1,poly2));});});return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (performActionOnAllFeaturePairs);\n\n/***/ }),\n\n/***/ 5853:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 5906:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 5907:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = __webpack_require__(5853);\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n\n\n/***/ }),\n\n/***/ 5908:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n/***/ }),\n\n/***/ 6141:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__ = __webpack_require__(5803);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__ = __webpack_require__(5824);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__ = __webpack_require__(6142);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__ = __webpack_require__(6145);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__ = __webpack_require__(6149);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__ = __webpack_require__(6153);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__ = __webpack_require__(5840);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__ = __webpack_require__(6155);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{dialogPaper:{minHeight:'50vh',overflowX:'hidden'},spaced:{marginBottom:50},container:{display:'flex',flexWrap:'wrap',width:'100%'}};};var GeoProcessingDialog=function(_Component){_inherits(GeoProcessingDialog,_Component);function GeoProcessingDialog(){var _ref;var _temp,_this,_ret;_classCallCheck(this,GeoProcessingDialog);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=GeoProcessingDialog.__proto__||Object.getPrototypeOf(GeoProcessingDialog)).call.apply(_ref,[this].concat(args))),_this),_this.state={processingFunction:null,layerIds:['',''],//Ids of the selectedLayers\noutputName:'',errorMessage:''},_this.setLayerIds=function(layerIds){_this.setState({layerIds:layerIds});},_this.setProcessingFunction=function(type){var func=null;switch(type){case'intersect':func=__WEBPACK_IMPORTED_MODULE_5__utils_geoprocessing_intersectFunction__[\"a\" /* default */];break;case'union':func=__WEBPACK_IMPORTED_MODULE_7__utils_geoprocessing_unionFunction__[\"a\" /* default */];break;case'difference':func=__WEBPACK_IMPORTED_MODULE_6__utils_geoprocessing_differenceFunction__[\"a\" /* default */];break;default:break;}_this.setState({processingFunction:func});},_this.calculate=function(){var _this$props=_this.props,closeDialog=_this$props.closeDialog,layers=_this$props.layers,receiveNewJson=_this$props.receiveNewJson;var _this$state=_this.state,processingFunction=_this$state.processingFunction,layerIds=_this$state.layerIds,outputName=_this$state.outputName;var l1=layers.find(function(l){return l.id===layerIds[0];});var l2=layers.find(function(l){return l.id===layerIds[1];});var data1=void 0,data2=void 0;if(l1){data1=l1.data;}if(l2){data2=l2.data;}var newJson=processingFunction(data1,data2);if(newJson.type===\"FeatureCollection\"){receiveNewJson(newJson,outputName);closeDialog();}else{_this.setState({errorMessage:newJson});}},_this.handleClose=function(){var closeDialog=_this.props.closeDialog;closeDialog();},_this.setName=function(name){_this.setState({outputName:name});},_this.getContent=function(type){if(type==='intersect'||type==='difference'||type==='union'){var _this$props2=_this.props,layers=_this$props2.layers,theme=_this$props2.theme;var _this$state2=_this.state,outputName=_this$state2.outputName,errorMessage=_this$state2.errorMessage,layerIds=_this$state2.layerIds;var prompt1=type==='difference'?'Input Layer':'Layer 1';var prompt2=type==='difference'?'Difference Layer':'Layer 2';var l1=layers.find(function(l){return l.id===layerIds[0];});var l2=layers.find(function(l){return l.id===layerIds[1];});if(l1){prompt1+=' (Type: '+l1.data.features[0].geometry.type+')';}if(l2){prompt2+=' (Type: '+l2.data.features[0].geometry.type+')';}var layerOptions=layers;if(type==='intersect'||type==='difference'){layerOptions=layers.filter(function(layer){return layer.type==='Polygon'||layer.type==='MultiPolygon';});}return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,errorMessage.length>0?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__[\"a\" /* default */],{message:errorMessage,variant:'error'}):null,type==='intersect'||type==='difference'?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_10__DialogContent_DialogFeedback__[\"a\" /* default */],{message:type+' operation only accepts Polygons'}):null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_8__DoubleLayerPicker__[\"a\" /* default */],{prompt1:prompt1,prompt2:prompt2,layers:layerOptions,setLayerIds:_this.setLayerIds.bind(_this)}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{style:{margin:theme.spacing.unit}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_9__LayerNameTextField__[\"a\" /* default */],{layerName:outputName,setName:_this.setName.bind(_this),defaultName:outputName,layers:layerOptions,layerIndex:-1,promt:'Output layer name'})));};return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,type));},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(GeoProcessingDialog,[{key:'componentDidMount',value:function componentDidMount(){var type=this.props.type;this.setProcessingFunction(type);this.setState({outputName:type});}},{key:'render',value:function render(){var _props=this.props,open=_props.open,layers=_props.layers,type=_props.type,classes=_props.classes;var content=layers.length>0?this.getContent(type):__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"e\" /* DialogContent */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,'Add some layers first'));var actions=layers.length>0?__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__DialogActions_SubmitOrCancelAction__[\"a\" /* default */],{submitText:'Calculate',submit:this.calculate,cancel:this.handleClose}):__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__DialogActions_OkAction__[\"a\" /* default */],{ok:this.handleClose});var diaglogTitle=type.charAt(0).toUpperCase()+type.slice(1);return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"c\" /* Dialog */],{fullWidth:true,open:open,onClose:this.handleClose,scroll:'paper','aria-labelledby':'scroll-dialog-title',classes:{paper:classes.dialogPaper}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"f\" /* DialogTitle */],{id:'scroll-dialog-title'},diaglogTitle),content,actions);}}]);return GeoProcessingDialog;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"default\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(GeoProcessingDialog));\n\n/***/ }),\n\n/***/ 6142:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_intersect__ = __webpack_require__(6143);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_intersect___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__turf_intersect__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5852);\nvar intersectFunction=function intersectFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!=='Polygon'&&geojson1.features[0].geometry.type!=='MultiPolygon'){return'The geometries must be of type Polygon or MultiPolygon.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_intersect___default.a);if(!newGeojson.features[0]){return'The geometries do not overlap';}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (intersectFunction);\n\n/***/ }),\n\n/***/ 6143:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5906);\r\nvar invariant_1 = __webpack_require__(6144);\r\nvar martinez = __importStar(__webpack_require__(5851));\r\n/**\r\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\r\n * finds their polygonal intersection. If they don't intersect, returns null.\r\n *\r\n * @name intersect\r\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\r\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\r\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\r\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *   [-122.801742, 45.48565],\r\n *   [-122.801742, 45.60491],\r\n *   [-122.584762, 45.60491],\r\n *   [-122.584762, 45.48565],\r\n *   [-122.801742, 45.48565]\r\n * ]]);\r\n *\r\n * var poly2 = turf.polygon([[\r\n *   [-122.520217, 45.535693],\r\n *   [-122.64038, 45.553967],\r\n *   [-122.720031, 45.526554],\r\n *   [-122.669906, 45.507309],\r\n *   [-122.723464, 45.446643],\r\n *   [-122.532577, 45.408574],\r\n *   [-122.487258, 45.477466],\r\n *   [-122.520217, 45.535693]\r\n * ]]);\r\n *\r\n * var intersection = turf.intersect(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, intersection];\r\n */\r\nfunction intersect(poly1, poly2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom1 = invariant_1.getGeom(poly1);\r\n    var geom2 = invariant_1.getGeom(poly2);\r\n    if (geom1.type === \"Polygon\" && geom2.type === \"Polygon\") {\r\n        var intersection = martinez.intersection(geom1.coordinates, geom2.coordinates);\r\n        if (intersection === null || intersection.length === 0) {\r\n            return null;\r\n        }\r\n        if (intersection.length === 1) {\r\n            var start = intersection[0][0][0];\r\n            var end = intersection[0][0][intersection[0][0].length - 1];\r\n            if (start[0] === end[0] && start[1] === end[1]) {\r\n                return helpers_1.polygon(intersection[0], options.properties);\r\n            }\r\n            return null;\r\n        }\r\n        return helpers_1.multiPolygon(intersection, options.properties);\r\n    }\r\n    else if (geom1.type === \"MultiPolygon\") {\r\n        var resultCoords = [];\r\n        // iterate through the polygon and run intersect with each part, adding to the resultCoords.\r\n        for (var _i = 0, _a = geom1.coordinates; _i < _a.length; _i++) {\r\n            var coords = _a[_i];\r\n            var subGeom = invariant_1.getGeom(helpers_1.polygon(coords));\r\n            var subIntersection = intersect(subGeom, geom2);\r\n            if (subIntersection) {\r\n                var subIntGeom = invariant_1.getGeom(subIntersection);\r\n                if (subIntGeom.type === \"Polygon\") {\r\n                    resultCoords.push(subIntGeom.coordinates);\r\n                }\r\n                else if (subIntGeom.type === \"MultiPolygon\") {\r\n                    resultCoords = resultCoords.concat(subIntGeom.coordinates);\r\n                }\r\n                else {\r\n                    throw new Error(\"intersection is invalid\");\r\n                }\r\n            }\r\n        }\r\n        // Make a polygon with the result\r\n        if (resultCoords.length === 0) {\r\n            return null;\r\n        }\r\n        if (resultCoords.length === 1) {\r\n            return helpers_1.polygon(resultCoords[0], options.properties);\r\n        }\r\n        else {\r\n            return helpers_1.multiPolygon(resultCoords, options.properties);\r\n        }\r\n    }\r\n    else if (geom2.type === \"MultiPolygon\") {\r\n        // geom1 is a polygon and geom2 a multiPolygon,\r\n        // put the multiPolygon first and fallback to the previous case.\r\n        return intersect(geom2, geom1);\r\n    }\r\n    else {\r\n        // handle invalid geometry types\r\n        throw new Error(\"poly1 and poly2 must be either polygons or multiPolygons\");\r\n    }\r\n}\r\nexports.default = intersect;\r\n\n\n/***/ }),\n\n/***/ 6144:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5906);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 6145:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_difference__ = __webpack_require__(6146);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5852);\nvar differenceFunction=function differenceFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!=='Polygon'&&geojson1.features[0].geometry.type!=='MultiPolygon'){return'The geometries must be of type Polygon or MultiPolygon.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_difference__[\"a\" /* default */]);if(!newGeojson.features[0]){return'There is no geometry left after performing the difference operation. Try swapping the order';}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (differenceFunction);\n\n/***/ }),\n\n/***/ 6146:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__ = __webpack_require__(5851);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_area__ = __webpack_require__(6147);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__turf_area___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__turf_area__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_helpers__ = __webpack_require__(5853);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__turf_helpers___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant__ = __webpack_require__(6148);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__turf_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__turf_meta__ = __webpack_require__(5907);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__turf_meta___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__turf_meta__);\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = Object(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__[\"getGeom\"])(polygon1);\r\n    var geom2 = Object(__WEBPACK_IMPORTED_MODULE_3__turf_invariant__[\"getGeom\"])(polygon2);\r\n    var properties = polygon1.properties || {};\r\n\r\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\r\n    geom1 = removeEmptyPolygon(geom1);\r\n    geom2 = removeEmptyPolygon(geom2);\r\n    if (!geom1) return null;\r\n    if (!geom2) return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"feature\"])(geom1, properties);\r\n\r\n    var differenced = __WEBPACK_IMPORTED_MODULE_0_martinez_polygon_clipping__[\"diff\"](geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    if (differenced.length === 1) return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"polygon\"])(differenced[0], properties);\r\n    return Object(__WEBPACK_IMPORTED_MODULE_2__turf_helpers__[\"multiPolygon\"])(differenced, properties);\r\n}\r\n\r\n/**\r\n * Detect Empty Polygon\r\n *\r\n * @private\r\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\r\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\r\n */\r\nfunction removeEmptyPolygon(geom) {\r\n    switch (geom.type) {\r\n    case 'Polygon':\r\n        if (__WEBPACK_IMPORTED_MODULE_1__turf_area___default()(geom) > 1) return geom;\r\n        return null;\r\n    case 'MultiPolygon':\r\n        var coordinates = [];\r\n        Object(__WEBPACK_IMPORTED_MODULE_4__turf_meta__[\"flattenEach\"])(geom, function (feature) {\r\n            if (__WEBPACK_IMPORTED_MODULE_1__turf_area___default()(feature) > 1) coordinates.push(feature.geometry.coordinates);\r\n        });\r\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\r\n    }\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (difference);\r\n\n\n/***/ }),\n\n/***/ 6147:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = __webpack_require__(5907);\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n\n\n/***/ }),\n\n/***/ 6148:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5853);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 6149:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_union__ = __webpack_require__(6150);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__turf_union___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__turf_union__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__ = __webpack_require__(5852);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__combineFeatures__ = __webpack_require__(6152);\nvar unionFunction=function unionFunction(geojson1,geojson2){if(!(geojson1&&geojson2)){return'Two geometries are required';}else if(geojson1.features[0].geometry.type!==geojson2.features[0].geometry.type){return'The geometries must be of the same type.';}else if(geojson1===geojson2){return'The geometries cannot be identical';}var newGeojson=void 0;if(geojson1.features[0].geometry.type==='Polygon'){newGeojson=Object(__WEBPACK_IMPORTED_MODULE_1__performActionOnAllFeaturePairs__[\"a\" /* default */])(geojson1,geojson2,__WEBPACK_IMPORTED_MODULE_0__turf_union___default.a);}else{newGeojson=Object(__WEBPACK_IMPORTED_MODULE_2__combineFeatures__[\"a\" /* default */])(geojson1,geojson2);}return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (unionFunction);\n\n/***/ }),\n\n/***/ 6150:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar martinez = __webpack_require__(5851);\r\nvar invariant_1 = __webpack_require__(6151);\r\nvar helpers_1 = __webpack_require__(5908);\r\n/**\r\n * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate Properties to output Feature\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(polygon1, polygon2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var coords1 = invariant_1.getGeom(polygon1).coordinates;\r\n    var coords2 = invariant_1.getGeom(polygon2).coordinates;\r\n    var unioned = martinez.union(coords1, coords2);\r\n    if (unioned.length === 0)\r\n        return null;\r\n    if (unioned.length === 1)\r\n        return helpers_1.polygon(unioned[0], options.properties);\r\n    else\r\n        return helpers_1.multiPolygon(unioned, options.properties);\r\n}\r\nexports.default = union;\r\n\n\n/***/ }),\n\n/***/ 6151:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = __webpack_require__(5908);\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n/***/ }),\n\n/***/ 6152:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//combines the features of two feature collections into one\nvar combineFeatures=function combineFeatures(FeatureCollection1,FeatureCollection2){var newGeojson={\"type\":\"FeatureCollection\",\"features\":[]};newGeojson.features=FeatureCollection1.features.concat(FeatureCollection2.features);return newGeojson;};/* harmony default export */ __webpack_exports__[\"a\"] = (combineFeatures);\n\n/***/ }),\n\n/***/ 6153:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__ = __webpack_require__(6154);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{spaced:{marginBottom:50},container:{display:'flex',flexWrap:'wrap',width:'100%'}};};var DoubleLayerPicker=function(_Component){_inherits(DoubleLayerPicker,_Component);function DoubleLayerPicker(){var _ref;var _temp,_this,_ret;_classCallCheck(this,DoubleLayerPicker);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=DoubleLayerPicker.__proto__||Object.getPrototypeOf(DoubleLayerPicker)).call.apply(_ref,[this].concat(args))),_this),_this.state={layerIds:['','']},_this.changeLayer1=function(layerId){var layerIds=_this.state.layerIds;var setLayerIds=_this.props.setLayerIds;layerIds[0]=layerId;setLayerIds(layerIds);_this.setState({layerIds:layerIds});},_this.changeLayer2=function(layerId){var layerIds=_this.state.layerIds;var setLayerIds=_this.props.setLayerIds;layerIds[1]=layerId;setLayerIds(layerIds);_this.setState({layerIds:layerIds});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(DoubleLayerPicker,[{key:'render',value:function render(){var _props=this.props,classes=_props.classes,prompt1=_props.prompt1,prompt2=_props.prompt2,layers=_props.layers;var layerIds=this.state.layerIds;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('form',{className:classes.container},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__[\"a\" /* default */],{className:classes.spaced,layers:layers,layerId:layerIds[0],changeLayer:this.changeLayer1.bind(this),promt:prompt1}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__LayersSelectSimple2__[\"a\" /* default */],{className:classes.spaced,layers:layers,layerId:layerIds[1],changeLayer:this.changeLayer2.bind(this),promt:prompt2})));}}]);return DoubleLayerPicker;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(DoubleLayerPicker));/* <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(0).bind(this)} />\r\n            <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(2).bind(this)} />  */\n\n/***/ }),\n\n/***/ 6154:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(53);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}//This is prefered over the original. Uses ids over indices.\nvar styles=function styles(theme){return{formControl:{margin:theme.spacing.unit,width:'100%'},Select:{width:'100%'}};};var LayersSelect=function(_React$Component){_inherits(LayersSelect,_React$Component);function LayersSelect(){var _ref;var _temp,_this,_ret;_classCallCheck(this,LayersSelect);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=LayersSelect.__proto__||Object.getPrototypeOf(LayersSelect)).call.apply(_ref,[this].concat(args))),_this),_this.state={curValue:''},_this.handleChange=function(name){return function(event){var changeLayer=_this.props.changeLayer;changeLayer(event.target.value);_this.setState(_defineProperty({},name,event.target.value));};},_this.setCurLayer=function(){var _this$props=_this.props,layerId=_this$props.layerId,layers=_this$props.layers;_this.setState({curValue:layerId});},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(LayersSelect,[{key:'componentDidMount',value:function componentDidMount(){this.setCurLayer();}},{key:'componentDidUpdate',value:function componentDidUpdate(prevProps){if(prevProps.layerId!==this.props.layerId){this.setCurLayer();}}},{key:'render',value:function render(){var _props=this.props,layers=_props.layers,classes=_props.classes,promt=_props.promt;var options=layers.map(function(layer,index){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"q\" /* MenuItem */],{key:layer.id,value:layer.id},layer.displayName);});var promtText=promt?promt:'Choose a Layer';return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"i\" /* FormControl */],{fullWidth:true,className:classes.formControl},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"k\" /* InputLabel */],{htmlFor:'age-simple'},promtText),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"r\" /* Select */],{value:this.state.curValue,onChange:this.handleChange('curValue'),placeholder:'Choose a Layer to edit'},options));}}]);return LayersSelect;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(LayersSelect));\n\n/***/ }),\n\n/***/ 6155:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__material_ui_core__ = __webpack_require__(53);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var styles=function styles(theme){return{feedbackDiv:{padding:theme.spacing.unit,borderRadius:5,margin:theme.spacing.unit}};};var DialogFeedback=function(_Component){_inherits(DialogFeedback,_Component);function DialogFeedback(){_classCallCheck(this,DialogFeedback);return _possibleConstructorReturn(this,(DialogFeedback.__proto__||Object.getPrototypeOf(DialogFeedback)).apply(this,arguments));}_createClass(DialogFeedback,[{key:'render',value:function render(){var _props=this.props,message=_props.message,classes=_props.classes,variant=_props.variant;var bgcolor='#2979ff';switch(variant){case'error':bgcolor='red';break;default:break;}return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{className:classes.feedbackDiv,style:{backgroundColor:bgcolor}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__material_ui_core__[\"z\" /* Typography */],null,' ',message));}}]);return DialogFeedback;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);/* harmony default export */ __webpack_exports__[\"a\"] = (Object(__WEBPACK_IMPORTED_MODULE_1__material_ui_core_styles__[\"withStyles\"])(styles,{withTheme:true})(DialogFeedback));\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/6.d8a4c15d.chunk.js","import React, {Component} from 'react';\r\nimport {\r\n    DialogActions,\r\n    Button} from '@material-ui/core'\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class SubmitOrCancelAction extends Component {\r\n    \r\n    render() {\r\n\r\n      const { submit, submitText , cancel, cancelText, submitDisabled } = this.props;\r\n\r\n      let submitBtnTxt = submitText ? submitText: 'Submit';\r\n      let cancelBtnTxt = cancelText ? cancelText: 'Cancel';\r\n      let disabled = submitDisabled ? true: false;\r\n  \r\n      return (\r\n        <DialogActions>\r\n            <Button variant='contained' disabled={disabled} onClick={submit}  color=\"primary\">\r\n              {submitBtnTxt}\r\n            </Button>\r\n            <Button onClick={cancel} color=\"primary\">\r\n              {cancelBtnTxt}\r\n            </Button>\r\n      </DialogActions>   \r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(SubmitOrCancelAction);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogActions/SubmitOrCancelAction.js","import React, {Component} from 'react';\r\nimport {\r\n    DialogActions,\r\n    Button} from '@material-ui/core'\r\nimport { withStyles } from '@material-ui/core/styles';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class OkAction extends Component {\r\n    \r\n    render() {\r\n\r\n      const { ok, okText } = this.props;\r\n\r\n      let okBtnTxt = okText ? okText: 'OK'\r\n  \r\n      return (\r\n        <DialogActions>\r\n            <Button onClick={ok}  color=\"primary\">\r\n              {okBtnTxt}\r\n            </Button>\r\n      </DialogActions>   \r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(OkAction);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogActions/OkAction.js","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport {TextField} from '@material-ui/core/';\r\nimport checkIfLayerNameExists from '../utils/checkIfLayerNameExists';\r\n\r\nconst styles = theme => ({\r\n  \r\n  });\r\n\r\n  class LayerNameTextField extends Component {\r\n\r\n    componentDidMount() {\r\n        const {defaultName} = this.props;\r\n        this.setState({layerName: defaultName})\r\n    }\r\n\r\n    nameChange = name => event => {\r\n        const {setName} = this.props;\r\n        setName(event.target.value);\r\n      }\r\n    \r\n    render() {\r\n\r\n      const { promt, layerName, layers, layerIndex} = this.props;\r\n\r\n      let Nameerror = false;\r\n      let errorText = '';\r\n  \r\n      if(layerName === '') {\r\n        errorText ='layer name cannot be empty';\r\n        Nameerror = true;\r\n      } else if ( checkIfLayerNameExists(layerName, layers, layerIndex)) {\r\n        // Name exists already and is not the same as this layers names\r\n        errorText ='That name is already in use';\r\n        Nameerror = true;\r\n      }\r\n      let promtText = promt? promt: \"Layer Name\";\r\n  \r\n      return (\r\n        <form>\r\n            <TextField\r\n            id=\"outlined-full-width\"\r\n            label={promtText}\r\n            value={layerName}\r\n            fullWidth={true}\r\n            error={Nameerror}\r\n            onChange={this.nameChange('')}      \r\n            margin=\"normal\"\r\n            variant=\"outlined\"\r\n            helperText={errorText}\r\n            InputLabelProps={{\r\n            shrink: true,\r\n            }}\r\n        />\r\n      </form>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(LayerNameTextField);\n\n\n// WEBPACK FOOTER //\n// ./src/components/LayerNameTextField.js","/**\n * martinez v0.4.3\n * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor\n *\n * @author Alex Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.martinez = {})));\n}(this, (function (exports) { 'use strict';\n\n  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n  var SplayTree = function SplayTree(compare, noDuplicates) {\n    if ( compare === void 0 ) compare = DEFAULT_COMPARE;\n    if ( noDuplicates === void 0 ) noDuplicates = false;\n\n    this._compare = compare;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  };\n\n  var prototypeAccessors = { size: { configurable: true } };\n\n\n  SplayTree.prototype.rotateLeft = function rotateLeft (x) {\n    var y = x.right;\n    if (y) {\n      x.right = y.left;\n      if (y.left) { y.left.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)              { this._root = y; }\n    else if (x === x.parent.left) { x.parent.left = y; }\n    else                        { x.parent.right = y; }\n    if (y) { y.left = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype.rotateRight = function rotateRight (x) {\n    var y = x.left;\n    if (y) {\n      x.left = y.right;\n      if (y.right) { y.right.parent = x; }\n      y.parent = x.parent;\n    }\n\n    if (!x.parent)             { this._root = y; }\n    else if(x === x.parent.left) { x.parent.left = y; }\n    else                       { x.parent.right = y; }\n    if (y) { y.right = x; }\n    x.parent = y;\n  };\n\n\n  SplayTree.prototype._splay = function _splay (x) {\n      var this$1 = this;\n\n    while (x.parent) {\n      var p = x.parent;\n      if (!p.parent) {\n        if (p.left === x) { this$1.rotateRight(p); }\n        else            { this$1.rotateLeft(p); }\n      } else if (p.left === x && p.parent.left === p) {\n        this$1.rotateRight(p.parent);\n        this$1.rotateRight(p);\n      } else if (p.right === x && p.parent.right === p) {\n        this$1.rotateLeft(p.parent);\n        this$1.rotateLeft(p);\n      } else if (p.left === x && p.parent.right === p) {\n        this$1.rotateRight(p);\n        this$1.rotateLeft(p);\n      } else {\n        this$1.rotateLeft(p);\n        this$1.rotateRight(p);\n      }\n    }\n  };\n\n\n  SplayTree.prototype.splay = function splay (x) {\n      var this$1 = this;\n\n    var p, gp, ggp, l, r;\n\n    while (x.parent) {\n      p = x.parent;\n      gp = p.parent;\n\n      if (gp && gp.parent) {\n        ggp = gp.parent;\n        if (ggp.left === gp) { ggp.left= x; }\n        else               { ggp.right = x; }\n        x.parent = ggp;\n      } else {\n        x.parent = null;\n        this$1._root = x;\n      }\n\n      l = x.left; r = x.right;\n\n      if (x === p.left) { // left\n        if (gp) {\n          if (gp.left === p) {\n            /* zig-zig */\n            if (p.right) {\n              gp.left = p.right;\n              gp.left.parent = gp;\n            } else { gp.left = null; }\n\n            p.right = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (l) {\n              gp.right = l;\n              l.parent = gp;\n            } else { gp.right = null; }\n\n            x.left  = gp;\n            gp.parent = x;\n          }\n        }\n        if (r) {\n          p.left = r;\n          r.parent = p;\n        } else { p.left = null; }\n\n        x.right= p;\n        p.parent = x;\n      } else { // right\n        if (gp) {\n          if (gp.right === p) {\n            /* zig-zig */\n            if (p.left) {\n              gp.right = p.left;\n              gp.right.parent = gp;\n            } else { gp.right = null; }\n\n            p.left = gp;\n            gp.parent = p;\n          } else {\n            /* zig-zag */\n            if (r) {\n              gp.left = r;\n              r.parent = gp;\n            } else { gp.left = null; }\n\n            x.right = gp;\n            gp.parent = x;\n          }\n        }\n        if (l) {\n          p.right = l;\n          l.parent = p;\n        } else { p.right = null; }\n\n        x.left = p;\n        p.parent = x;\n      }\n    }\n  };\n\n\n  SplayTree.prototype.replace = function replace (u, v) {\n    if (!u.parent) { this._root = v; }\n    else if (u === u.parent.left) { u.parent.left = v; }\n    else { u.parent.right = v; }\n    if (v) { v.parent = u.parent; }\n  };\n\n\n  SplayTree.prototype.minNode = function minNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.left) { u = u.left; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.maxNode = function maxNode (u) {\n      if ( u === void 0 ) u = this._root;\n\n    if (u) { while (u.right) { u = u.right; } }\n    return u;\n  };\n\n\n  SplayTree.prototype.insert = function insert (key, data) {\n    var z = this._root;\n    var p = null;\n    var comp = this._compare;\n    var cmp;\n\n    if (this._noDuplicates) {\n      while (z) {\n        p = z;\n        cmp = comp(z.key, key);\n        if (cmp === 0) { return; }\n        else if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    } else {\n      while (z) {\n        p = z;\n        if (comp(z.key, key) < 0) { z = z.right; }\n        else { z = z.left; }\n      }\n    }\n\n    z = { key: key, data: data, left: null, right: null, parent: p };\n\n    if (!p)                        { this._root = z; }\n    else if (comp(p.key, z.key) < 0) { p.right = z; }\n    else                           { p.left= z; }\n\n    this.splay(z);\n    this._size++;\n    return z;\n  };\n\n\n  SplayTree.prototype.find = function find (key) {\n    var z  = this._root;\n    var comp = this._compare;\n    while (z) {\n      var cmp = comp(z.key, key);\n      if    (cmp < 0) { z = z.right; }\n      else if (cmp > 0) { z = z.left; }\n      else            { return z; }\n    }\n    return null;\n  };\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param{Key} key\n   * @return {boolean} true/false\n   */\n  SplayTree.prototype.contains = function contains (key) {\n    var node     = this._root;\n    var comparator = this._compare;\n    while (node){\n      var cmp = comparator(key, node.key);\n      if    (cmp === 0) { return true; }\n      else if (cmp < 0) { node = node.left; }\n      else              { node = node.right; }\n    }\n\n    return false;\n  };\n\n\n  SplayTree.prototype.remove = function remove (key) {\n    var z = this.find(key);\n\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.removeNode = function removeNode (z) {\n    if (!z) { return false; }\n\n    this.splay(z);\n\n    if (!z.left) { this.replace(z, z.right); }\n    else if (!z.right) { this.replace(z, z.left); }\n    else {\n      var y = this.minNode(z.right);\n      if (y.parent !== z) {\n        this.replace(y, y.right);\n        y.right = z.right;\n        y.right.parent = y;\n      }\n      this.replace(z, y);\n      y.left = z.left;\n      y.left.parent = y;\n    }\n\n    this._size--;\n    return true;\n  };\n\n\n  SplayTree.prototype.erase = function erase (key) {\n    var z = this.find(key);\n    if (!z) { return; }\n\n    this.splay(z);\n\n    var s = z.left;\n    var t = z.right;\n\n    var sMax = null;\n    if (s) {\n      s.parent = null;\n      sMax = this.maxNode(s);\n      this.splay(sMax);\n      this._root = sMax;\n    }\n    if (t) {\n      if (s) { sMax.right = t; }\n      else { this._root = t; }\n      t.parent = sMax;\n    }\n\n    this._size--;\n  };\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  SplayTree.prototype.pop = function pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) { node = node.left; }\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  };\n\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.next = function next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor && successor.left) { successor = successor.left; }\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  };\n\n\n  /**\n   * Predecessor node\n   * @param{Node} node\n   * @return {?Node}\n   */\n  SplayTree.prototype.prev = function prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor && predecessor.right) { predecessor = predecessor.right; }\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  };\n  /* eslint-enable class-methods-use-this */\n\n\n  /**\n   * @param{forEachCallback} callback\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.forEach = function forEach (callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return this;\n  };\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param{Key}    low\n   * @param{Key}    high\n   * @param{Function} fn\n   * @param{*?}     ctx\n   * @return {SplayTree}\n   */\n  SplayTree.prototype.range = function range (low, high, fn, ctx) {\n      var this$1 = this;\n\n    var Q = [];\n    var compare = this._compare;\n    var node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  SplayTree.prototype.keys = function keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  SplayTree.prototype.values = function values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return r;\n  };\n\n\n  /**\n   * Returns node at given index\n   * @param{number} index\n   * @return {?Node}\n   */\n  SplayTree.prototype.at = function at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) { return current; }\n          i++;\n          current = current.right;\n        } else { done = true; }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param{Array<Key>}  keys\n   * @param{Array<Value>}[values]\n   * @param{Boolean}     [presort=false] Pre-sort keys and values, using\n   *                                       tree's comparator. Sorting is done\n   *                                       in-place\n   * @return {AVLTree}\n   */\n  SplayTree.prototype.load = function load (keys, values, presort) {\n      if ( keys === void 0 ) keys = [];\n      if ( values === void 0 ) values = [];\n      if ( presort === void 0 ) presort = false;\n\n    if (this._size !== 0) { throw new Error('bulk-load: tree is not empty'); }\n    var size = keys.length;\n    if (presort) { sort(keys, values, 0, size - 1, this._compare); }\n    this._root = loadRecursive(null, keys, values, 0, size);\n    this._size = size;\n    return this;\n  };\n\n\n  SplayTree.prototype.min = function min () {\n    var node = this.minNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n\n  SplayTree.prototype.max = function max () {\n    var node = this.maxNode(this._root);\n    if (node) { return node.key; }\n    else    { return null; }\n  };\n\n  SplayTree.prototype.isEmpty = function isEmpty () { return this._root === null; };\n  prototypeAccessors.size.get = function () { return this._size; };\n\n\n  /**\n   * Create a tree and load it with items\n   * @param{Array<Key>}        keys\n   * @param{Array<Value>?}      [values]\n\n   * @param{Function?}          [comparator]\n   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using\n   *                                             tree's comparator. Sorting is done\n   *                                             in-place\n   * @param{Boolean?}           [noDuplicates=false] Allow duplicates\n   * @return {SplayTree}\n   */\n  SplayTree.createTree = function createTree (keys, values, comparator, presort, noDuplicates) {\n    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);\n  };\n\n  Object.defineProperties( SplayTree.prototype, prototypeAccessors );\n\n\n  function loadRecursive (parent, keys, values, start, end) {\n    var size = end - start;\n    if (size > 0) {\n      var middle = start + Math.floor(size / 2);\n      var key    = keys[middle];\n      var data   = values[middle];\n      var node   = { key: key, data: data, parent: parent };\n      node.left    = loadRecursive(node, keys, values, start, middle);\n      node.right   = loadRecursive(node, keys, values, middle + 1, end);\n      return node;\n    }\n    return null;\n  }\n\n\n  function sort(keys, values, left, right, compare) {\n    if (left >= right) { return; }\n\n    var pivot = keys[(left + right) >> 1];\n    var i = left - 1;\n    var j = right + 1;\n\n    while (true) {\n      do { i++; } while (compare(keys[i], pivot) < 0);\n      do { j--; } while (compare(keys[j], pivot) > 0);\n      if (i >= j) { break; }\n\n      var tmp = keys[i];\n      keys[i] = keys[j];\n      keys[j] = tmp;\n\n      tmp = values[i];\n      values[i] = values[j];\n      values[j] = tmp;\n    }\n\n    sort(keys, values,  left,     j, compare);\n    sort(keys, values, j + 1, right, compare);\n  }\n\n  var NORMAL               = 0;\n  var NON_CONTRIBUTING     = 1;\n  var SAME_TRANSITION      = 2;\n  var DIFFERENT_TRANSITION = 3;\n\n  var INTERSECTION = 0;\n  var UNION        = 1;\n  var DIFFERENCE   = 2;\n  var XOR          = 3;\n\n  /**\n   * @param  {SweepEvent} event\n   * @param  {SweepEvent} prev\n   * @param  {Operation} operation\n   */\n  function computeFields (event, prev, operation) {\n    // compute inOut and otherInOut fields\n    if (prev === null) {\n      event.inOut      = false;\n      event.otherInOut = true;\n\n    // previous line segment in sweepline belongs to the same polygon\n    } else {\n      if (event.isSubject === prev.isSubject) {\n        event.inOut      = !prev.inOut;\n        event.otherInOut = prev.otherInOut;\n\n      // previous line segment in sweepline belongs to the clipping polygon\n      } else {\n        event.inOut      = !prev.otherInOut;\n        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n      }\n\n      // compute prevInResult field\n      if (prev) {\n        event.prevInResult = (!inResult(prev, operation) || prev.isVertical())\n          ? prev.prevInResult : prev;\n      }\n    }\n\n    // check if the line segment belongs to the Boolean operation\n    event.inResult = inResult(event, operation);\n  }\n\n\n  /* eslint-disable indent */\n  function inResult(event, operation) {\n    switch (event.type) {\n      case NORMAL:\n        switch (operation) {\n          case INTERSECTION:\n            return !event.otherInOut;\n          case UNION:\n            return event.otherInOut;\n          case DIFFERENCE:\n            // return (event.isSubject && !event.otherInOut) ||\n            //         (!event.isSubject && event.otherInOut);\n            return (event.isSubject && event.otherInOut) ||\n                    (!event.isSubject && !event.otherInOut);\n          case XOR:\n            return true;\n        }\n        break;\n      case SAME_TRANSITION:\n        return operation === INTERSECTION || operation === UNION;\n      case DIFFERENT_TRANSITION:\n        return operation === DIFFERENCE;\n      case NON_CONTRIBUTING:\n        return false;\n    }\n    return false;\n  }\n  /* eslint-enable indent */\n\n  var SweepEvent = function SweepEvent (point, left, otherEvent, isSubject, edgeType) {\n\n    /**\n     * Is left endpoint?\n     * @type {Boolean}\n     */\n    this.left = left;\n\n    /**\n     * @type {Array.<Number>}\n     */\n    this.point = point;\n\n    /**\n     * Other edge reference\n     * @type {SweepEvent}\n     */\n    this.otherEvent = otherEvent;\n\n    /**\n     * Belongs to source or clipping polygon\n     * @type {Boolean}\n     */\n    this.isSubject = isSubject;\n\n    /**\n     * Edge contribution type\n     * @type {Number}\n     */\n    this.type = edgeType || NORMAL;\n\n\n    /**\n     * In-out transition for the sweepline crossing polygon\n     * @type {Boolean}\n     */\n    this.inOut = false;\n\n\n    /**\n     * @type {Boolean}\n     */\n    this.otherInOut = false;\n\n    /**\n     * Previous event in result?\n     * @type {SweepEvent}\n     */\n    this.prevInResult = null;\n\n    /**\n     * Does event belong to result?\n     * @type {Boolean}\n     */\n    this.inResult = false;\n\n\n    // connection step\n\n    /**\n     * @type {Boolean}\n     */\n    this.resultInOut = false;\n\n    this.isExteriorRing = true;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isBelow = function isBelow (p) {\n    var p0 = this.point, p1 = this.otherEvent.point;\n    return this.left\n      ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0\n      // signedArea(this.point, this.otherEvent.point, p) > 0 :\n      : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0;\n      //signedArea(this.otherEvent.point, this.point, p) > 0;\n  };\n\n\n  /**\n   * @param{Array.<Number>}p\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isAbove = function isAbove (p) {\n    return !this.isBelow(p);\n  };\n\n\n  /**\n   * @return {Boolean}\n   */\n  SweepEvent.prototype.isVertical = function isVertical () {\n    return this.point[0] === this.otherEvent.point[0];\n  };\n\n\n  SweepEvent.prototype.clone = function clone () {\n    var copy = new SweepEvent(\n      this.point, this.left, this.otherEvent, this.isSubject, this.type);\n\n    copy.inResult     = this.inResult;\n    copy.prevInResult = this.prevInResult;\n    copy.isExteriorRing = this.isExteriorRing;\n    copy.inOut        = this.inOut;\n    copy.otherInOut   = this.otherInOut;\n\n    return copy;\n  };\n\n  function equals(p1, p2) {\n    if (p1[0] === p2[0]) {\n      if (p1[1] === p2[1]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  // const EPSILON = 1e-9;\n  // const abs = Math.abs;\n  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164\n  // Precision problem.\n  //\n  // module.exports = function equals(p1, p2) {\n  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;\n  // };\n\n  /**\n   * Signed area of the triangle (p0, p1, p2)\n   * @param  {Array.<Number>} p0\n   * @param  {Array.<Number>} p1\n   * @param  {Array.<Number>} p2\n   * @return {Number}\n   */\n  function signedArea(p0, p1, p2) {\n    return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n  }\n\n  /**\n   * @param  {SweepEvent} e1\n   * @param  {SweepEvent} e2\n   * @return {Number}\n   */\n  function compareEvents(e1, e2) {\n    var p1 = e1.point;\n    var p2 = e2.point;\n\n    // Different x-coordinate\n    if (p1[0] > p2[0]) { return 1; }\n    if (p1[0] < p2[0]) { return -1; }\n\n    // Different points, but same x-coordinate\n    // Event with lower y-coordinate is processed first\n    if (p1[1] !== p2[1]) { return p1[1] > p2[1] ? 1 : -1; }\n\n    return specialCases(e1, e2, p1, p2);\n  }\n\n\n  /* eslint-disable no-unused-vars */\n  function specialCases(e1, e2, p1, p2) {\n    // Same coordinates, but one is a left endpoint and the other is\n    // a right endpoint. The right endpoint is processed first\n    if (e1.left !== e2.left)\n      { return e1.left ? 1 : -1; }\n\n    // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;\n    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    // Same coordinates, both events\n    // are left endpoints or right endpoints.\n    // not collinear\n    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n      // the event associate to the bottom segment is processed first\n      return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n    }\n\n    return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n  }\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * @param  {SweepEvent} se\n   * @param  {Array.<Number>} p\n   * @param  {Queue} queue\n   * @return {Queue}\n   */\n  function divideSegment(se, p, queue)  {\n    var r = new SweepEvent(p, false, se,            se.isSubject);\n    var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n    /* eslint-disable no-console */\n    if (equals(se.point, se.otherEvent.point)) {\n\n      console.warn('what is that, a collapsed segment?', se);\n    }\n    /* eslint-enable no-console */\n\n    r.contourId = l.contourId = se.contourId;\n\n    // avoid a rounding error. The left event would be processed after the right event\n    if (compareEvents(l, se.otherEvent) > 0) {\n      se.otherEvent.left = true;\n      l.left = false;\n    }\n\n    // avoid a rounding error. The left event would be processed after the right event\n    // if (compareEvents(se, r) > 0) {}\n\n    se.otherEvent.otherEvent = l;\n    se.otherEvent = r;\n\n    queue.push(l);\n    queue.push(r);\n\n    return queue;\n  }\n\n  //const EPS = 1e-9;\n\n  /**\n   * Finds the magnitude of the cross product of two vectors (if we pretend\n   * they're in three dimensions)\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The magnitude of the cross product\n   */\n  function crossProduct(a, b) {\n    return (a[0] * b[1]) - (a[1] * b[0]);\n  }\n\n  /**\n   * Finds the dot product of two vectors.\n   *\n   * @param {Object} a First vector\n   * @param {Object} b Second vector\n   * @private\n   * @returns {Number} The dot product\n   */\n  function dotProduct(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]);\n  }\n\n  /**\n   * Finds the intersection (if any) between two line segments a and b, given the\n   * line segments' end points a1, a2 and b1, b2.\n   *\n   * This algorithm is based on Schneider and Eberly.\n   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n   * Page 244.\n   *\n   * @param {Array.<Number>} a1 point of first line\n   * @param {Array.<Number>} a2 point of first line\n   * @param {Array.<Number>} b1 point of second line\n   * @param {Array.<Number>} b2 point of second line\n   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n   *                                         (meaning connected segments) as\n   *                                         intersections\n   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n   * intersection. If they overlap, the two end points of the overlapping segment.\n   * Otherwise, null.\n   */\n  function intersection (a1, a2, b1, b2, noEndpointTouch) {\n    // The algorithm expects our lines in the form P + sd, where P is a point,\n    // s is on the interval [0, 1], and d is a vector.\n    // We are passed two points. P can be the first point of each pair. The\n    // vector, then, could be thought of as the distance (in x and y components)\n    // from the first point to the second point.\n    // So first, let's make our vectors:\n    var va = [a2[0] - a1[0], a2[1] - a1[1]];\n    var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n    // We also define a function to convert back to regular point form:\n\n    /* eslint-disable arrow-body-style */\n\n    function toPoint(p, s, d) {\n      return [\n        p[0] + s * d[0],\n        p[1] + s * d[1]\n      ];\n    }\n\n    /* eslint-enable arrow-body-style */\n\n    // The rest is pretty much a straight port of the algorithm.\n    var e = [b1[0] - a1[0], b1[1] - a1[1]];\n    var kross    = crossProduct(va, vb);\n    var sqrKross = kross * kross;\n    var sqrLenA  = dotProduct(va, va);\n    //const sqrLenB  = dotProduct(vb, vb);\n\n    // Check for line intersection. This works because of the properties of the\n    // cross product -- specifically, two vectors are parallel if and only if the\n    // cross product is the 0 vector. The full calculation involves relative error\n    // to account for possible very small line segments. See Schneider & Eberly\n    // for details.\n    if (sqrKross > 0/* EPS * sqrLenB * sqLenA */) {\n      // If they're not parallel, then (because these are line segments) they\n      // still might not actually intersect. This code checks that the\n      // intersection point of the lines is actually on both line segments.\n      var s = crossProduct(e, vb) / kross;\n      if (s < 0 || s > 1) {\n        // not on line segment a\n        return null;\n      }\n      var t = crossProduct(e, va) / kross;\n      if (t < 0 || t > 1) {\n        // not on line segment b\n        return null;\n      }\n      if (s === 0 || s === 1) {\n        // on an endpoint of line segment a\n        return noEndpointTouch ? null : [toPoint(a1, s, va)];\n      }\n      if (t === 0 || t === 1) {\n        // on an endpoint of line segment b\n        return noEndpointTouch ? null : [toPoint(b1, t, vb)];\n      }\n      return [toPoint(a1, s, va)];\n    }\n\n    // If we've reached this point, then the lines are either parallel or the\n    // same, but the segments could overlap partially or fully, or not at all.\n    // So we need to find the overlap, if any. To do that, we can use e, which is\n    // the (vector) difference between the two initial points. If this is parallel\n    // with the line itself, then the two lines are the same line, and there will\n    // be overlap.\n    //const sqrLenE = dotProduct(e, e);\n    kross = crossProduct(e, va);\n    sqrKross = kross * kross;\n\n    if (sqrKross > 0 /* EPS * sqLenB * sqLenE */) {\n    // Lines are just parallel, not the same. No overlap.\n      return null;\n    }\n\n    var sa = dotProduct(va, e) / sqrLenA;\n    var sb = sa + dotProduct(va, vb) / sqrLenA;\n    var smin = Math.min(sa, sb);\n    var smax = Math.max(sa, sb);\n\n    // this is, essentially, the FindIntersection acting on floats from\n    // Schneider & Eberly, just inlined into this function.\n    if (smin <= 1 && smax >= 0) {\n\n      // overlap on an end point\n      if (smin === 1) {\n        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n      }\n\n      if (smax === 0) {\n        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n      }\n\n      if (noEndpointTouch && smin === 0 && smax === 1) { return null; }\n\n      // There's overlap on a segment -- two points of intersection. Return both.\n      return [\n        toPoint(a1, smin > 0 ? smin : 0, va),\n        toPoint(a1, smax < 1 ? smax : 1, va)\n      ];\n    }\n\n    return null;\n  }\n\n  /**\n   * @param  {SweepEvent} se1\n   * @param  {SweepEvent} se2\n   * @param  {Queue}      queue\n   * @return {Number}\n   */\n  function possibleIntersection (se1, se2, queue) {\n    // that disallows self-intersecting polygons,\n    // did cost us half a day, so I'll leave it\n    // out of respect\n    // if (se1.isSubject === se2.isSubject) return;\n    var inter = intersection(\n      se1.point, se1.otherEvent.point,\n      se2.point, se2.otherEvent.point\n    );\n\n    var nintersections = inter ? inter.length : 0;\n    if (nintersections === 0) { return 0; } // no intersection\n\n    // the line segments intersect at an endpoint of both line segments\n    if ((nintersections === 1) &&\n        (equals(se1.point, se2.point) ||\n         equals(se1.otherEvent.point, se2.otherEvent.point))) {\n      return 0;\n    }\n\n    if (nintersections === 2 && se1.isSubject === se2.isSubject) {\n      // if(se1.contourId === se2.contourId){\n      // console.warn('Edges of the same polygon overlap',\n      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n      // }\n      //throw new Error('Edges of the same polygon overlap');\n      return 0;\n    }\n\n    // The line segments associated to se1 and se2 intersect\n    if (nintersections === 1) {\n\n      // if the intersection point is not an endpoint of se1\n      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n        divideSegment(se1, inter[0], queue);\n      }\n\n      // if the intersection point is not an endpoint of se2\n      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n        divideSegment(se2, inter[0], queue);\n      }\n      return 1;\n    }\n\n    // The line segments associated to se1 and se2 overlap\n    var events        = [];\n    var leftCoincide  = false;\n    var rightCoincide = false;\n\n    if (equals(se1.point, se2.point)) {\n      leftCoincide = true; // linked\n    } else if (compareEvents(se1, se2) === 1) {\n      events.push(se2, se1);\n    } else {\n      events.push(se1, se2);\n    }\n\n    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n      rightCoincide = true;\n    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n      events.push(se2.otherEvent, se1.otherEvent);\n    } else {\n      events.push(se1.otherEvent, se2.otherEvent);\n    }\n\n    if ((leftCoincide && rightCoincide) || leftCoincide) {\n      // both line segments are equal or share the left endpoint\n      se2.type = NON_CONTRIBUTING;\n      se1.type = (se2.inOut === se1.inOut)\n        ? SAME_TRANSITION : DIFFERENT_TRANSITION;\n\n      if (leftCoincide && !rightCoincide) {\n        // honestly no idea, but changing events selection from [2, 1]\n        // to [0, 1] fixes the overlapping self-intersecting polygons issue\n        divideSegment(events[1].otherEvent, events[0].point, queue);\n      }\n      return 2;\n    }\n\n    // the line segments share the right endpoint\n    if (rightCoincide) {\n      divideSegment(events[0], events[1].point, queue);\n      return 3;\n    }\n\n    // no line segment includes totally the other one\n    if (events[0] !== events[3].otherEvent) {\n      divideSegment(events[0], events[1].point, queue);\n      divideSegment(events[1], events[2].point, queue);\n      return 3;\n    }\n\n    // one line segment includes the other one\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[3].otherEvent, events[2].point, queue);\n\n    return 3;\n  }\n\n  /**\n   * @param  {SweepEvent} le1\n   * @param  {SweepEvent} le2\n   * @return {Number}\n   */\n  function compareSegments(le1, le2) {\n    if (le1 === le2) { return 0; }\n\n    // Segments are not collinear\n    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n      signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n      // If they share their left endpoint use the right endpoint to sort\n      if (equals(le1.point, le2.point)) { return le1.isBelow(le2.otherEvent.point) ? -1 : 1; }\n\n      // Different left endpoint: use the left endpoint to sort\n      if (le1.point[0] === le2.point[0]) { return le1.point[1] < le2.point[1] ? -1 : 1; }\n\n      // has the line segment associated to e1 been inserted\n      // into S after the line segment associated to e2 ?\n      if (compareEvents(le1, le2) === 1) { return le2.isAbove(le1.point) ? -1 : 1; }\n\n      // The line segment associated to e2 has been inserted\n      // into S after the line segment associated to e1\n      return le1.isBelow(le2.point) ? -1 : 1;\n    }\n\n    if (le1.isSubject === le2.isSubject) { // same polygon\n      var p1 = le1.point, p2 = le2.point;\n      if (p1[0] === p2[0] && p1[1] === p2[1]/*equals(le1.point, le2.point)*/) {\n        p1 = le1.otherEvent.point; p2 = le2.otherEvent.point;\n        if (p1[0] === p2[0] && p1[1] === p2[1]) { return 0; }\n        else { return le1.contourId > le2.contourId ? 1 : -1; }\n      }\n    } else { // Segments are collinear, but belong to separate polygons\n      return le1.isSubject ? -1 : 1;\n    }\n\n    return compareEvents(le1, le2) === 1 ? 1 : -1;\n  }\n\n  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n    var sweepLine = new SplayTree(compareSegments);\n    var sortedEvents = [];\n\n    var rightbound = Math.min(sbbox[2], cbbox[2]);\n\n    var prev, next, begin;\n\n    while (eventQueue.length !== 0) {\n      var event = eventQueue.pop();\n      sortedEvents.push(event);\n\n      // optimization by bboxes for intersection and difference goes here\n      if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n          (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n        break;\n      }\n\n      if (event.left) {\n        next  = prev = sweepLine.insert(event);\n        begin = sweepLine.minNode();\n\n        if (prev !== begin) { prev = sweepLine.prev(prev); }\n        else                { prev = null; }\n\n        next = sweepLine.next(next);\n\n        var prevEvent = prev ? prev.key : null;\n        var prevprevEvent = (void 0);\n        computeFields(event, prevEvent, operation);\n        if (next) {\n          if (possibleIntersection(event, next.key, eventQueue) === 2) {\n            computeFields(event, prevEvent, operation);\n            computeFields(event, next.key, operation);\n          }\n        }\n\n        if (prev) {\n          if (possibleIntersection(prev.key, event, eventQueue) === 2) {\n            var prevprev = prev;\n            if (prevprev !== begin) { prevprev = sweepLine.prev(prevprev); }\n            else                    { prevprev = null; }\n\n            prevprevEvent = prevprev ? prevprev.key : null;\n            computeFields(prevEvent, prevprevEvent, operation);\n            computeFields(event,     prevEvent,     operation);\n          }\n        }\n      } else {\n        event = event.otherEvent;\n        next = prev = sweepLine.find(event);\n\n        if (prev && next) {\n\n          if (prev !== begin) { prev = sweepLine.prev(prev); }\n          else                { prev = null; }\n\n          next = sweepLine.next(next);\n          sweepLine.remove(event);\n\n          if (next && prev) {\n            possibleIntersection(prev.key, next.key, eventQueue);\n          }\n        }\n      }\n    }\n    return sortedEvents;\n  }\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<SweepEvent>}\n   */\n  function orderEvents(sortedEvents) {\n    var event, i, len, tmp;\n    var resultEvents = [];\n    for (i = 0, len = sortedEvents.length; i < len; i++) {\n      event = sortedEvents[i];\n      if ((event.left && event.inResult) ||\n        (!event.left && event.otherEvent.inResult)) {\n        resultEvents.push(event);\n      }\n    }\n    // Due to overlapping edges the resultEvents array can be not wholly sorted\n    var sorted = false;\n    while (!sorted) {\n      sorted = true;\n      for (i = 0, len = resultEvents.length; i < len; i++) {\n        if ((i + 1) < len &&\n          compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n          tmp = resultEvents[i];\n          resultEvents[i] = resultEvents[i + 1];\n          resultEvents[i + 1] = tmp;\n          sorted = false;\n        }\n      }\n    }\n\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      event.pos = i;\n    }\n\n    // imagine, the right event is found in the beginning of the queue,\n    // when his left counterpart is not marked yet\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      event = resultEvents[i];\n      if (!event.left) {\n        tmp = event.pos;\n        event.pos = event.otherEvent.pos;\n        event.otherEvent.pos = tmp;\n      }\n    }\n\n    return resultEvents;\n  }\n\n\n  /**\n   * @param  {Number} pos\n   * @param  {Array.<SweepEvent>} resultEvents\n   * @param  {Object>}    processed\n   * @return {Number}\n   */\n  function nextPos(pos, resultEvents, processed, origIndex) {\n    var newPos = pos + 1;\n    var length = resultEvents.length;\n    if (newPos > length - 1) { return pos - 1; }\n    var p  = resultEvents[pos].point;\n    var p1 = resultEvents[newPos].point;\n\n\n    // while in range and not the current one by value\n    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {\n      if (!processed[newPos]) {\n        return newPos;\n      } else   {\n        newPos++;\n      }\n      p1 = resultEvents[newPos].point;\n    }\n\n    newPos = pos - 1;\n\n    while (processed[newPos] && newPos >= origIndex) {\n      newPos--;\n    }\n    return newPos;\n  }\n\n\n  /**\n   * @param  {Array.<SweepEvent>} sortedEvents\n   * @return {Array.<*>} polygons\n   */\n  function connectEdges(sortedEvents, operation) {\n    var i, len;\n    var resultEvents = orderEvents(sortedEvents);\n\n    // \"false\"-filled array\n    var processed = {};\n    var result = [];\n    var event;\n\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if (processed[i]) { continue; }\n      var contour = [[]];\n\n      if (!resultEvents[i].isExteriorRing) {\n        if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length === 0) {\n          result.push(contour);\n        } else if (result.length === 0) {\n          result.push([[contour]]);\n        } else {\n          result[result.length - 1].push(contour[0]);\n        }\n      } else if (operation === DIFFERENCE && !resultEvents[i].isSubject && result.length > 1) {\n        result[result.length - 1].push(contour[0]);\n      } else {\n        result.push(contour);\n      }\n\n      var ringId = result.length - 1;\n      var pos = i;\n\n      var initial = resultEvents[i].point;\n      contour[0].push(initial);\n\n      while (pos >= i) {\n        event = resultEvents[pos];\n        processed[pos] = true;\n\n        if (event.left) {\n          event.resultInOut = false;\n          event.contourId   = ringId;\n        } else {\n          event.otherEvent.resultInOut = true;\n          event.otherEvent.contourId   = ringId;\n        }\n\n        pos = event.pos;\n        processed[pos] = true;\n        contour[0].push(resultEvents[pos].point);\n        pos = nextPos(pos, resultEvents, processed, i);\n      }\n\n      pos = pos === -1 ? i : pos;\n\n      event = resultEvents[pos];\n      processed[pos] = processed[event.pos] = true;\n      event.otherEvent.resultInOut = true;\n      event.otherEvent.contourId   = ringId;\n    }\n\n    // Handle if the result is a polygon (eg not multipoly)\n    // Commented it again, let's see what do we mean by that\n    // if (result.length === 1) result = result[0];\n    return result;\n  }\n\n  var tinyqueue = TinyQueue;\n  var default_1 = TinyQueue;\n\n  function TinyQueue(data, compare) {\n      var this$1 = this;\n\n      if (!(this instanceof TinyQueue)) { return new TinyQueue(data, compare); }\n\n      this.data = data || [];\n      this.length = this.data.length;\n      this.compare = compare || defaultCompare;\n\n      if (this.length > 0) {\n          for (var i = (this.length >> 1) - 1; i >= 0; i--) { this$1._down(i); }\n      }\n  }\n\n  function defaultCompare(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  TinyQueue.prototype = {\n\n      push: function (item) {\n          this.data.push(item);\n          this.length++;\n          this._up(this.length - 1);\n      },\n\n      pop: function () {\n          if (this.length === 0) { return undefined; }\n\n          var top = this.data[0];\n          this.length--;\n\n          if (this.length > 0) {\n              this.data[0] = this.data[this.length];\n              this._down(0);\n          }\n          this.data.pop();\n\n          return top;\n      },\n\n      peek: function () {\n          return this.data[0];\n      },\n\n      _up: function (pos) {\n          var data = this.data;\n          var compare = this.compare;\n          var item = data[pos];\n\n          while (pos > 0) {\n              var parent = (pos - 1) >> 1;\n              var current = data[parent];\n              if (compare(item, current) >= 0) { break; }\n              data[pos] = current;\n              pos = parent;\n          }\n\n          data[pos] = item;\n      },\n\n      _down: function (pos) {\n          var this$1 = this;\n\n          var data = this.data;\n          var compare = this.compare;\n          var halfLength = this.length >> 1;\n          var item = data[pos];\n\n          while (pos < halfLength) {\n              var left = (pos << 1) + 1;\n              var right = left + 1;\n              var best = data[left];\n\n              if (right < this$1.length && compare(data[right], best) < 0) {\n                  left = right;\n                  best = data[right];\n              }\n              if (compare(best, item) >= 0) { break; }\n\n              data[pos] = best;\n              pos = left;\n          }\n\n          data[pos] = item;\n      }\n  };\n  tinyqueue.default = default_1;\n\n  var max = Math.max;\n  var min = Math.min;\n\n  var contourId = 0;\n\n\n  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {\n    var i, len, s1, s2, e1, e2;\n    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {\n      s1 = contourOrHole[i];\n      s2 = contourOrHole[i + 1];\n      e1 = new SweepEvent(s1, false, undefined, isSubject);\n      e2 = new SweepEvent(s2, false, e1,        isSubject);\n      e1.otherEvent = e2;\n\n      if (s1[0] === s2[0] && s1[1] === s2[1]) {\n        continue; // skip collapsed edges, or it breaks\n      }\n\n      e1.contourId = e2.contourId = depth;\n      if (!isExteriorRing) {\n        e1.isExteriorRing = false;\n        e2.isExteriorRing = false;\n      }\n      if (compareEvents(e1, e2) > 0) {\n        e2.left = true;\n      } else {\n        e1.left = true;\n      }\n\n      var x = s1[0], y = s1[1];\n      bbox[0] = min(bbox[0], x);\n      bbox[1] = min(bbox[1], y);\n      bbox[2] = max(bbox[2], x);\n      bbox[3] = max(bbox[3], y);\n\n      // Pushing it so the queue is sorted from left to right,\n      // with object on the left having the highest priority.\n      Q.push(e1);\n      Q.push(e2);\n    }\n  }\n\n\n  function fillQueue(subject, clipping, sbbox, cbbox, operation) {\n    var eventQueue = new tinyqueue(null, compareEvents);\n    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;\n\n    for (i = 0, ii = subject.length; i < ii; i++) {\n      polygonSet = subject[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);\n      }\n    }\n\n    for (i = 0, ii = clipping.length; i < ii; i++) {\n      polygonSet = clipping[i];\n      for (j = 0, jj = polygonSet.length; j < jj; j++) {\n        isExteriorRing = j === 0;\n        if (operation === DIFFERENCE) { isExteriorRing = false; }\n        if (isExteriorRing) { contourId++; }\n        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);\n      }\n    }\n\n    return eventQueue;\n  }\n\n  var EMPTY = [];\n\n\n  function trivialOperation(subject, clipping, operation) {\n    var result = null;\n    if (subject.length * clipping.length === 0) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = (subject.length === 0) ? clipping : subject;\n      }\n    }\n    return result;\n  }\n\n\n  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n    var result = null;\n    if (sbbox[0] > cbbox[2] ||\n        cbbox[0] > sbbox[2] ||\n        sbbox[1] > cbbox[3] ||\n        cbbox[1] > sbbox[3]) {\n      if        (operation === INTERSECTION) {\n        result = EMPTY;\n      } else if (operation === DIFFERENCE) {\n        result = subject;\n      } else if (operation === UNION ||\n                 operation === XOR) {\n        result = subject.concat(clipping);\n      }\n    }\n    return result;\n  }\n\n\n  function boolean(subject, clipping, operation) {\n    if (typeof subject[0][0][0] === 'number') {\n      subject = [subject];\n    }\n    if (typeof clipping[0][0][0] === 'number') {\n      clipping = [clipping];\n    }\n    var trivial = trivialOperation(subject, clipping, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n    var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    //console.time('fill queue');\n    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('fill queue');\n\n    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n    if (trivial) {\n      return trivial === EMPTY ? null : trivial;\n    }\n    //console.time('subdivide edges');\n    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation);\n    //console.timeEnd('subdivide edges');\n\n    //console.time('connect vertices');\n    var result = connectEdges(sortedEvents, operation);\n    //console.timeEnd('connect vertices');\n    return result;\n  }\n\n  function union (subject, clipping) {\n    return boolean(subject, clipping, UNION);\n  }\n\n  function diff (subject, clipping) {\n    return boolean(subject, clipping, DIFFERENCE);\n  }\n\n  function xor (subject, clipping){\n    return boolean(subject, clipping, XOR);\n  }\n\n  function intersection$1 (subject, clipping) {\n    return boolean(subject, clipping, INTERSECTION);\n  }\n\n  /**\n   * @enum {Number}\n   */\n  var operations = { UNION: UNION, DIFFERENCE: DIFFERENCE, INTERSECTION: INTERSECTION, XOR: XOR };\n\n  exports.union = union;\n  exports.diff = diff;\n  exports.xor = xor;\n  exports.intersection = intersection$1;\n  exports.operations = operations;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=martinez.umd.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/martinez-polygon-clipping/dist/martinez.umd.js\n// module id = 5851\n// module chunks = 6","const performActionOnAllFeaturePairs = (FeatureCollection1, FeatureCollection2, action) => {\r\n\r\n    let newGeojson = {\r\n      \"type\": \"FeatureCollection\",\r\n      \"features\": []\r\n    }\r\n\r\n    FeatureCollection1.features.forEach(poly1 => {\r\n        FeatureCollection2.features.forEach(poly2 => {\r\n        newGeojson.features.push(action(poly1, poly2))\r\n      });\r\n    });\r\n\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default performActionOnAllFeaturePairs\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/performActionOnAllFeaturePairs.js","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/helpers/index.js\n// module id = 5853\n// module chunks = 6","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/node_modules/@turf/helpers/index.js\n// module id = 5906\n// module chunks = 6","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/meta/index.js\n// module id = 5907\n// module chunks = 6","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/node_modules/@turf/helpers/index.js\n// module id = 5908\n// module chunks = 6","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport {Dialog,\r\n    Typography,\r\n    DialogContent,\r\n    DialogTitle,\r\n    } from '@material-ui/core';\r\nimport SubmitOrCancelAction from '../DialogActions/SubmitOrCancelAction';\r\nimport OkAction from '../DialogActions/OkAction'\r\nimport intersectFunction from '../../utils/geoprocessing/intersectFunction';\r\nimport differenceFunction from '../../utils/geoprocessing/differenceFunction';\r\nimport unionFunction from '../../utils/geoprocessing/unionFunction';\r\nimport DoubleLayerPicker from '../DoubleLayerPicker';\r\nimport LayerNameTextField from '../LayerNameTextField';\r\nimport DialogFeedback from '../DialogContent/DialogFeedback';\r\n\r\n\r\nconst styles = theme => ({\r\n    dialogPaper: {\r\n        minHeight: '50vh',\r\n        overflowX:'hidden'\r\n      },\r\n      spaced: {\r\n        marginBottom: 50,\r\n      },\r\n      container: {\r\n        display: 'flex',\r\n        flexWrap: 'wrap',\r\n        width:'100%'\r\n      },\r\n  });\r\n\r\n  class GeoProcessingDialog extends Component {\r\n    state = {\r\n        processingFunction: null,\r\n        layerIds: ['', ''], //Ids of the selectedLayers\r\n        outputName:'',\r\n        errorMessage:''\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {type} = this.props;\r\n        this.setProcessingFunction(type);\r\n        this.setState({outputName: type});\r\n    }\r\n\r\n    setLayerIds = (layerIds) => {\r\n      this.setState({layerIds: layerIds})\r\n    }\r\n\r\n    setProcessingFunction = (type) => {\r\n        let func = null;\r\n  \r\n        switch (type) {\r\n          case 'intersect':\r\n            func = intersectFunction;\r\n            break;\r\n          case 'union':\r\n            func = unionFunction;\r\n            break;\r\n          case 'difference':\r\n            func = differenceFunction;\r\n            break;\r\n        \r\n          default:\r\n            break;\r\n        }\r\n        this.setState({processingFunction: func});\r\n      }\r\n\r\n    calculate = () => {\r\n    const {closeDialog, layers, receiveNewJson} = this.props;\r\n    const {processingFunction, layerIds, outputName} = this.state;\r\n\r\n    let l1 = layers.find( l => l.id === layerIds[0] );\r\n    let l2 = layers.find( l => l.id === layerIds[1] );\r\n    let data1, data2;\r\n\r\n      if (l1) {\r\n        data1 = l1.data;\r\n      } if (l2) {\r\n        data2 = l2.data;\r\n      } \r\n\r\n       let newJson = processingFunction(data1, data2);\r\n\r\n       if(newJson.type === \"FeatureCollection\") {\r\n        receiveNewJson(newJson, outputName)\r\n        closeDialog();\r\n       } else {\r\n         this.setState({errorMessage: newJson});\r\n       }\r\n       \r\n    };\r\n\r\n    handleClose = () => {\r\n        const {closeDialog} = this.props;\r\n        closeDialog();\r\n    };\r\n\r\n    setName  = (name) => {\r\n      this.setState({outputName: name});\r\n    }\r\n\r\n    getContent = type => {\r\n      \r\n      if(type === 'intersect' || type === 'difference' || type === 'union'){\r\n        const {layers, theme} = this.props;\r\n        const {outputName, errorMessage, layerIds} = this.state;\r\n        let prompt1 = type === 'difference' ? 'Input Layer' : 'Layer 1'\r\n        let prompt2 = type === 'difference' ? 'Difference Layer' : 'Layer 2'\r\n\r\n        let l1 = layers.find( l => l.id === layerIds[0] )\r\n        let l2 = layers.find( l => l.id === layerIds[1] )\r\n\r\n        if(l1) {\r\n          prompt1 += ' (Type: ' + l1.data.features[0].geometry.type  + ')'\r\n        }\r\n        if(l2) {\r\n          prompt2 += ' (Type: ' + l2.data.features[0].geometry.type  + ')'\r\n        }\r\n\r\n        let layerOptions = layers;\r\n\r\n        if (type === 'intersect' || type === 'difference' ) {\r\n          layerOptions = layers.filter(layer => layer.type === 'Polygon' || layer.type === 'MultiPolygon' );\r\n        }\r\n\r\n        return (\r\n            <DialogContent>\r\n              {errorMessage.length > 0 ?\r\n                <DialogFeedback message={errorMessage} variant={'error'} />\r\n                : null\r\n              }\r\n              {type === 'intersect' || type === 'difference'  ?\r\n                <DialogFeedback message={type + ' operation only accepts Polygons'}/>\r\n                :\r\n                null\r\n              }\r\n              \r\n              <DoubleLayerPicker prompt1={prompt1}\r\n                  prompt2={prompt2}\r\n                  layers={layerOptions}\r\n                  setLayerIds={this.setLayerIds.bind(this)}/>\r\n                <div style={{margin: theme.spacing.unit}}>\r\n                <LayerNameTextField\r\n                  layerName={outputName}\r\n                  setName={this.setName.bind(this)}\r\n                  defaultName={outputName}\r\n                  layers={layerOptions}\r\n                  layerIndex={-1}\r\n                  promt={'Output layer name'} />\r\n                \r\n                  </div>         \r\n            </DialogContent> );\r\n        };\r\n\r\n        return (\r\n            <DialogContent>\r\n                <Typography>{type}</Typography>            \r\n            </DialogContent> );\r\n    }\r\n\r\n\r\n    \r\n    render() {\r\n\r\n      const {open, layers, type, classes} = this.props;\r\n     \r\n      let content = layers.length > 0 ?\r\n      this.getContent(type)\r\n      : \r\n      <DialogContent>\r\n        <Typography>Add some layers first</Typography>         \r\n      </DialogContent>\r\n\r\n        let actions = layers.length > 0 ?\r\n        <SubmitOrCancelAction submitText='Calculate' submit={this.calculate} cancel={this.handleClose}/>\r\n        : \r\n        <OkAction ok={this.handleClose}/>\r\n\r\n        let diaglogTitle = type.charAt(0).toUpperCase() + type.slice(1);\r\n  \r\n      return (\r\n        <Dialog\r\n        fullWidth={true}\r\n        open={open}\r\n        onClose={this.handleClose}\r\n        scroll={'paper'}\r\n        aria-labelledby=\"scroll-dialog-title\"\r\n        classes={{ paper: classes.dialogPaper }}\r\n        \r\n      >\r\n          <DialogTitle id=\"scroll-dialog-title\">{diaglogTitle}</DialogTitle>\r\n            {content}\r\n            {actions}\r\n      </Dialog>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(GeoProcessingDialog);\n\n\n// WEBPACK FOOTER //\n// ./src/components/Dialogs/GeoProcessingDialog.js","import  intersect from '@turf/intersect';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\n\r\nconst intersectFunction = (geojson1, geojson2) => {\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== 'Polygon' && geojson1.features[0].geometry.type !== 'MultiPolygon'  ) {\r\n    return 'The geometries must be of type Polygon or MultiPolygon.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n  \r\n  let newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, intersect)\r\n    if (!newGeojson.features[0]) {\r\n      return 'The geometries do not overlap'\r\n    }\r\n    return newGeojson;\r\n  }\r\n\r\n  export default intersectFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/intersectFunction.js","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\nvar invariant_1 = require(\"@turf/invariant\");\r\nvar martinez = __importStar(require(\"martinez-polygon-clipping\"));\r\n/**\r\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\r\n * finds their polygonal intersection. If they don't intersect, returns null.\r\n *\r\n * @name intersect\r\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\r\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\r\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\r\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *   [-122.801742, 45.48565],\r\n *   [-122.801742, 45.60491],\r\n *   [-122.584762, 45.60491],\r\n *   [-122.584762, 45.48565],\r\n *   [-122.801742, 45.48565]\r\n * ]]);\r\n *\r\n * var poly2 = turf.polygon([[\r\n *   [-122.520217, 45.535693],\r\n *   [-122.64038, 45.553967],\r\n *   [-122.720031, 45.526554],\r\n *   [-122.669906, 45.507309],\r\n *   [-122.723464, 45.446643],\r\n *   [-122.532577, 45.408574],\r\n *   [-122.487258, 45.477466],\r\n *   [-122.520217, 45.535693]\r\n * ]]);\r\n *\r\n * var intersection = turf.intersect(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, intersection];\r\n */\r\nfunction intersect(poly1, poly2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var geom1 = invariant_1.getGeom(poly1);\r\n    var geom2 = invariant_1.getGeom(poly2);\r\n    if (geom1.type === \"Polygon\" && geom2.type === \"Polygon\") {\r\n        var intersection = martinez.intersection(geom1.coordinates, geom2.coordinates);\r\n        if (intersection === null || intersection.length === 0) {\r\n            return null;\r\n        }\r\n        if (intersection.length === 1) {\r\n            var start = intersection[0][0][0];\r\n            var end = intersection[0][0][intersection[0][0].length - 1];\r\n            if (start[0] === end[0] && start[1] === end[1]) {\r\n                return helpers_1.polygon(intersection[0], options.properties);\r\n            }\r\n            return null;\r\n        }\r\n        return helpers_1.multiPolygon(intersection, options.properties);\r\n    }\r\n    else if (geom1.type === \"MultiPolygon\") {\r\n        var resultCoords = [];\r\n        // iterate through the polygon and run intersect with each part, adding to the resultCoords.\r\n        for (var _i = 0, _a = geom1.coordinates; _i < _a.length; _i++) {\r\n            var coords = _a[_i];\r\n            var subGeom = invariant_1.getGeom(helpers_1.polygon(coords));\r\n            var subIntersection = intersect(subGeom, geom2);\r\n            if (subIntersection) {\r\n                var subIntGeom = invariant_1.getGeom(subIntersection);\r\n                if (subIntGeom.type === \"Polygon\") {\r\n                    resultCoords.push(subIntGeom.coordinates);\r\n                }\r\n                else if (subIntGeom.type === \"MultiPolygon\") {\r\n                    resultCoords = resultCoords.concat(subIntGeom.coordinates);\r\n                }\r\n                else {\r\n                    throw new Error(\"intersection is invalid\");\r\n                }\r\n            }\r\n        }\r\n        // Make a polygon with the result\r\n        if (resultCoords.length === 0) {\r\n            return null;\r\n        }\r\n        if (resultCoords.length === 1) {\r\n            return helpers_1.polygon(resultCoords[0], options.properties);\r\n        }\r\n        else {\r\n            return helpers_1.multiPolygon(resultCoords, options.properties);\r\n        }\r\n    }\r\n    else if (geom2.type === \"MultiPolygon\") {\r\n        // geom1 is a polygon and geom2 a multiPolygon,\r\n        // put the multiPolygon first and fallback to the previous case.\r\n        return intersect(geom2, geom1);\r\n    }\r\n    else {\r\n        // handle invalid geometry types\r\n        throw new Error(\"poly1 and poly2 must be either polygons or multiPolygons\");\r\n    }\r\n}\r\nexports.default = intersect;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/index.js\n// module id = 6143\n// module chunks = 6","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/intersect/node_modules/@turf/invariant/index.js\n// module id = 6144\n// module chunks = 6","import  difference from '@turf/difference';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\n\r\nconst differenceFunction = (geojson1, geojson2) => {\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== 'Polygon' && geojson1.features[0].geometry.type !== 'MultiPolygon'  ) {\r\n    return 'The geometries must be of type Polygon or MultiPolygon.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n    let newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, difference)\r\n    if (!newGeojson.features[0]) {\r\n      return 'There is no geometry left after performing the difference operation. Try swapping the order'\r\n    }\r\n    return(newGeojson);\r\n    \r\n  }\r\n\r\n  export default differenceFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/differenceFunction.js","import * as martinez from 'martinez-polygon-clipping';\r\nimport area from '@turf/area';\r\nimport { feature, multiPolygon, polygon } from '@turf/helpers';\r\nimport { getGeom } from '@turf/invariant';\r\nimport { flattenEach } from '@turf/meta';\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = getGeom(polygon1);\r\n    var geom2 = getGeom(polygon2);\r\n    var properties = polygon1.properties || {};\r\n\r\n    // Issue #721 - JSTS/Martinez can't handle empty polygons\r\n    geom1 = removeEmptyPolygon(geom1);\r\n    geom2 = removeEmptyPolygon(geom2);\r\n    if (!geom1) return null;\r\n    if (!geom2) return feature(geom1, properties);\r\n\r\n    var differenced = martinez.diff(geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    if (differenced.length === 1) return polygon(differenced[0], properties);\r\n    return multiPolygon(differenced, properties);\r\n}\r\n\r\n/**\r\n * Detect Empty Polygon\r\n *\r\n * @private\r\n * @param {Geometry<Polygon|MultiPolygon>} geom Geometry Object\r\n * @returns {Geometry<Polygon|MultiPolygon>|null} removed any polygons with no areas\r\n */\r\nfunction removeEmptyPolygon(geom) {\r\n    switch (geom.type) {\r\n    case 'Polygon':\r\n        if (area(geom) > 1) return geom;\r\n        return null;\r\n    case 'MultiPolygon':\r\n        var coordinates = [];\r\n        flattenEach(geom, function (feature) {\r\n            if (area(feature) > 1) coordinates.push(feature.geometry.coordinates);\r\n        });\r\n        if (coordinates.length) return {type: 'MultiPolygon', coordinates: coordinates};\r\n    }\r\n}\r\n\r\nexport default difference;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/index.mjs\n// module id = 6146\n// module chunks = 6","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nfunction area(geojson) {\n    return meta_1.geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\nexports.default = area;\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = total * RADIUS * RADIUS / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return num * Math.PI / 180;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/area/index.js\n// module id = 6147\n// module chunks = 6","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/difference/node_modules/@turf/invariant/index.js\n// module id = 6148\n// module chunks = 6","import  union from '@turf/union';\r\nimport performActionOnAllFeaturePairs from './performActionOnAllFeaturePairs';\r\nimport combineFeatures from './combineFeatures';\r\n\r\nconst unionFunction = (geojson1, geojson2) => {\r\n\r\n  if( !(geojson1 && geojson2) ) {\r\n    return 'Two geometries are required'\r\n  } else if (geojson1.features[0].geometry.type !== geojson2.features[0].geometry.type ) {\r\n    return 'The geometries must be of the same type.'\r\n  } else if (geojson1 === geojson2) {\r\n    return 'The geometries cannot be identical'\r\n  }\r\n\r\n  let newGeojson;\r\n\r\n  if(geojson1.features[0].geometry.type === 'Polygon') {\r\n    newGeojson = performActionOnAllFeaturePairs(geojson1, geojson2, union);\r\n  } else {\r\n    newGeojson =  combineFeatures(geojson1, geojson2)\r\n  }\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default unionFunction\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/unionFunction.js","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar martinez = require(\"martinez-polygon-clipping\");\r\nvar invariant_1 = require(\"@turf/invariant\");\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Takes two {@link (Multi)Polygon(s)} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Object} [options.properties={}] Translate Properties to output Feature\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(polygon1, polygon2, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var coords1 = invariant_1.getGeom(polygon1).coordinates;\r\n    var coords2 = invariant_1.getGeom(polygon2).coordinates;\r\n    var unioned = martinez.union(coords1, coords2);\r\n    if (unioned.length === 0)\r\n        return null;\r\n    if (unioned.length === 1)\r\n        return helpers_1.polygon(unioned[0], options.properties);\r\n    else\r\n        return helpers_1.multiPolygon(unioned, options.properties);\r\n}\r\nexports.default = union;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/index.js\n// module id = 6150\n// module chunks = 6","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@turf/union/node_modules/@turf/invariant/index.js\n// module id = 6151\n// module chunks = 6","//combines the features of two feature collections into one\r\nconst combineFeatures = (FeatureCollection1, FeatureCollection2) => {\r\n\r\n    let newGeojson = {\r\n      \"type\": \"FeatureCollection\",\r\n      \"features\": []\r\n    }\r\n\r\n    newGeojson.features = FeatureCollection1.features.concat(FeatureCollection2.features);\r\n    return(newGeojson);\r\n  }\r\n\r\n  export default combineFeatures\n\n\n// WEBPACK FOOTER //\n// ./src/utils/geoprocessing/combineFeatures.js","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport LayersSelect from './LayersSelectSimple2';\r\n\r\nconst styles = theme => ({\r\n    spaced: {\r\n      marginBottom: 50,\r\n    },\r\n    container: {\r\n      display: 'flex',\r\n      flexWrap: 'wrap',\r\n      width:'100%'\r\n    },\r\n  });\r\n\r\n  class DoubleLayerPicker extends Component {\r\n    state = {\r\n      layerIds: ['', '']\r\n    };\r\n\r\n    changeLayer1 = (layerId) => {\r\n      let {layerIds} = this.state;\r\n      let {setLayerIds} = this.props;\r\n\r\n      layerIds[0] = layerId;\r\n      setLayerIds(layerIds);\r\n \r\n      this.setState({\r\n        layerIds: layerIds,\r\n      });\r\n    }\r\n\r\n    changeLayer2 = (layerId) => {\r\n      let {layerIds} = this.state;\r\n      let {setLayerIds} = this.props;\r\n\r\n      layerIds[1] = layerId;\r\n      setLayerIds(layerIds);\r\n \r\n      this.setState({\r\n        layerIds: layerIds,\r\n      });\r\n    }\r\n    \r\n    render() {\r\n\r\n      const { classes,  prompt1, prompt2, layers } = this.props;\r\n      const {layerIds} = this.state;\r\n  \r\n      return (\r\n        <div>\r\n        <form className={classes.container}>\r\n        <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerId={layerIds[0]}\r\n            changeLayer={this.changeLayer1.bind(this)}\r\n            promt={prompt1} />\r\n          <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerId={layerIds[1]}\r\n            changeLayer={this.changeLayer2.bind(this)}\r\n            promt={prompt2} />\r\n        </form>\r\n        </div>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(DoubleLayerPicker);\r\n         /* <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(0).bind(this)} />\r\n            <LayersSelect\r\n            className={classes.spaced}\r\n            layers={layers}\r\n            layerIndex={layerIndex}\r\n            changeLayer={this.changeLayer(2).bind(this)} />  */\n\n\n// WEBPACK FOOTER //\n// ./src/components/DoubleLayerPicker.js","\r\nimport React from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport { FormControl, InputLabel, MenuItem, Select}  from '@material-ui/core'\r\n\r\n//This is prefered over the original. Uses ids over indices.\r\n\r\nconst styles = theme => ({\r\n  formControl: {\r\n    margin: theme.spacing.unit,\r\n    width: '100%',\r\n  },\r\n  Select:{\r\n    width: '100%',\r\n  }\r\n});\r\n\r\n\r\n\r\nclass LayersSelect extends React.Component {\r\n  state = {\r\n    curValue: '',\r\n  };\r\n\r\n  handleChange = name => event => {\r\n    const {changeLayer} = this.props\r\n\r\n    changeLayer(event.target.value)\r\n    this.setState({ [name]: event.target.value });\r\n  };\r\n\r\n  componentDidMount() {\r\n    this.setCurLayer();\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (prevProps.layerId !== this.props.layerId) {\r\n      this.setCurLayer();\r\n    }\r\n  }\r\n\r\n  setCurLayer = () => {\r\n    const {layerId, layers} = this.props;\r\n\r\n    this.setState({curValue: layerId});\r\n  }\r\n\r\n  render() {\r\n    const { layers, classes, promt } = this.props;\r\n    let options = layers.map((layer, index) => {\r\n\r\n      return <MenuItem key={layer.id} value={layer.id}>{layer.displayName}</MenuItem >\r\n\r\n    }); \r\n\r\n    let promtText = promt ? promt : 'Choose a Layer';\r\n\r\n    return (\r\n\r\n    <FormControl fullWidth={true} className={classes.formControl}>\r\n      <InputLabel htmlFor=\"age-simple\">{promtText}</InputLabel>\r\n      <Select\r\n        value={this.state.curValue}\r\n        onChange={this.handleChange('curValue')}\r\n        placeholder=\"Choose a Layer to edit\"\r\n      >\r\n        {options}\r\n      </Select>\r\n    </FormControl>\r\n    );\r\n  }\r\n}\r\n\r\nexport default withStyles(styles, { withTheme: true })(LayersSelect);\n\n\n// WEBPACK FOOTER //\n// ./src/components/LayersSelectSimple2.js","import React, {Component} from 'react';\r\nimport { withStyles } from '@material-ui/core/styles';\r\nimport { Typography} from '@material-ui/core';\r\n\r\nconst styles = theme => ({\r\n    feedbackDiv: {\r\n       padding: theme.spacing.unit,\r\n       borderRadius: 5,\r\n       margin: theme.spacing.unit\r\n\r\n    }\r\n  });\r\n\r\n  class DialogFeedback extends Component {\r\n    \r\n    render() {\r\n\r\n      const { message, classes, variant } = this.props;\r\n\r\n      let bgcolor = '#2979ff'\r\n\r\n      switch (variant) {\r\n          case 'error':\r\n            bgcolor = 'red';\r\n            break;              \r\n      \r\n          default:\r\n              break;\r\n      }\r\n  \r\n      return (\r\n        <div className={classes.feedbackDiv} style={{backgroundColor: bgcolor}}>\r\n            <Typography> {message}</Typography>\r\n        </div>\r\n      );\r\n  \r\n  \r\n    }\r\n\r\n  }\r\n\r\nexport default withStyles(styles, { withTheme: true })(DialogFeedback);\n\n\n// WEBPACK FOOTER //\n// ./src/components/DialogContent/DialogFeedback.js"],"sourceRoot":""}